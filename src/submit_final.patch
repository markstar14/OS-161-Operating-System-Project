diff --git a/.gdbinit b/.gdbinit
new file mode 100644
index 0000000..1904f91
--- /dev/null
+++ b/.gdbinit
@@ -0,0 +1,2 @@
+target remote unix:.sockets/gdb
+break panic
diff --git a/kern/arch/mips/locore/trap.c b/kern/arch/mips/locore/trap.c
index ff39633..a3a7fd4 100644
--- a/kern/arch/mips/locore/trap.c
+++ b/kern/arch/mips/locore/trap.c
@@ -39,7 +39,9 @@
 #include <vm.h>
 #include <mainbus.h>
 #include <syscall.h>
-
+#include <synch.h>
+#include <kern/proccalls.h>
+#include <kern/wait.h>
 
 /* in exception.S */
 extern void asm_usermode(struct trapframe *tf);
@@ -114,7 +116,19 @@ kill_curthread(vaddr_t epc, unsigned code, vaddr_t vaddr)
 
 	kprintf("Fatal user mode trap %u sig %d (%s, epc 0x%x, vaddr 0x%x)\n",
 		code, sig, trapcodenames[code], epc, vaddr);
-	panic("I don't know how to handle this\n");
+	if(curthread->pid == 1){
+		V(menu_semaphore);
+	}
+	else {
+		
+                proc_tbl[curthread->pid]->exit_code = _MKWAIT_EXIT(1);
+                proc_tbl[curthread->pid]->exit = true;
+                V(proc_tbl[curthread->pid]->sem);
+        
+
+	}
+	thread_exit();
+//	panic("I don't know how to handle this\n");
 }
 
 /*
diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
index 0f773bd..fd02394 100644
--- a/kern/arch/mips/syscall/syscall.c
+++ b/kern/arch/mips/syscall/syscall.c
@@ -27,14 +27,19 @@
  * SUCH DAMAGE.
  */
 
+//#include <syscall.h>
 #include <types.h>
 #include <kern/errno.h>
+//#include <syscall.h>
 #include <kern/syscall.h>
 #include <lib.h>
 #include <mips/trapframe.h>
+#include <kern/proccalls.h>
 #include <thread.h>
 #include <current.h>
 #include <syscall.h>
+//#include <kern/proccalls.h>
+#include <copyinout.h>
 
 
 /*
@@ -71,6 +76,7 @@
  * call will repeat forever.
  *
  * If you run out of registers (which happens quickly with 64-bit
+
  * values) further arguments must be fetched from the user-level
  * stack, starting at sp+16 to skip over the slots for the
  * registerized values, with copyin().
@@ -78,14 +84,17 @@
 void
 syscall(struct trapframe *tf)
 {
-	int callno;
-	int32_t retval;
+	int callno, whence, res;
+	int32_t retval, ret;
 	int err;
+	off_t offset;
 
 	KASSERT(curthread != NULL);
 	KASSERT(curthread->t_curspl == 0);
 	KASSERT(curthread->t_iplhigh_count == 0);
 
+//	kprintf("%d\n", tf->tf_v0);	
+
 	callno = tf->tf_v0;
 
 	/*
@@ -99,25 +108,111 @@ syscall(struct trapframe *tf)
 
 	retval = 0;
 
+//	kprintf("the syscall running now is %d", callno);
+
 	switch (callno) {
-	    case SYS_reboot:
-		err = sys_reboot(tf->tf_a0);
-		break;
+		case SYS_reboot:
+			err = sys_reboot(tf->tf_a0);
+			break;
 
-	    case SYS___time:
-		err = sys___time((userptr_t)tf->tf_a0,
+	    	case SYS___time:
+			err = sys___time((userptr_t)tf->tf_a0,
 				 (userptr_t)tf->tf_a1);
-		break;
+			break;
+		
+		case SYS_open:
+			err = sys_open((const char *)tf->tf_a0, tf->tf_a1, &retval);
+			break;
+		
+		case SYS_close:
+			err = sys_close(tf->tf_a0);
+			break;
+
+		case SYS_read:
+			err = sys_read(tf->tf_a0,(void *)tf->tf_a1, tf->tf_a2,&retval);
+			break;
+
+		case SYS_write:
+			err = sys_write(tf->tf_a0,(const char *)tf->tf_a1, tf->tf_a2,&retval);
+			break;
+
+		case SYS_lseek:
+		{
+//			kprintf("reached lseek\n");
+			offset = (off_t)tf->tf_a2;
+			offset = offset << 32;
+			offset+=tf->tf_a3;
+			if((res = copyin((const_userptr_t)(tf->tf_sp + 16), &whence, sizeof(int))))
+			{
+				err = res;
+				break;
+			}
+//			kprintf("reached sys_lseek\n");
+			err = sys_lseek(tf->tf_a0, offset , whence, &retval, &ret);
+//			retval = (int)ret;
+			if(!err)
+			{
+				tf->tf_v1 = ret;// >> 32;
+/*				retval = (uint32_t)((ret & 0xFFFFFFFF00000000) >> 32);
+				ret = (uint32_t)(ret & 0xffffffff);
+				tf->tf_v1 = ret;
+*/			}
+			break;
+		}
+		case SYS_dup2:
+			err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
+			break;
+		
+		case SYS_chdir:
+			err = sys_chdir((const char *)tf->tf_a0);
+			break;
+
+		case SYS__exit:
+			sys_exit(tf->tf_a0);
+			err = 0;
+			break;
+	
+		case SYS___getcwd:
+			err = sys___getcwd((char *)tf->tf_a0, (size_t)tf->tf_a1, &retval);
+			break;
+		
+		case SYS_getpid:
+			retval = sys_getpid(); 
+			err = 0;
+			break;
+
+		case SYS_waitpid:
+			err = sys_waitpid((pid_t)tf->tf_a0, (int *)tf->tf_a1, tf->tf_a2, &retval);
+			break;
+
+		case SYS_fork:
+//			kprintf("called sys_fork\n");
+			err = sys_fork(tf, &retval);
+			break;
+		
+		case SYS_execv:
+			err = sys_execv((const char*)tf->tf_a0, (char **)tf->tf_a1);
+			retval = 0;
+			break;	
+
+		case SYS_sbrk:
+			err = sys_sbrk((intptr_t)tf->tf_a0, &retval);		
+			break;			
 
 	    /* Add stuff here */
  
 	    default:
-		kprintf("Unknown syscall %d\n", callno);
-		err = ENOSYS;
+
 		break;
 	}
 
 
+
+//	kprintf("finished syscall and the return value is %d\n", retval);
+
+	
+	
+
 	if (err) {
 		/*
 		 * Return the error code. This gets converted at
@@ -126,6 +221,7 @@ syscall(struct trapframe *tf)
 		 */
 		tf->tf_v0 = err;
 		tf->tf_a3 = 1;      /* signal an error */
+//		kprintf("error caused in syscall %d, error code %d\n", callno, err);
 	}
 	else {
 		/* Success. */
@@ -139,6 +235,7 @@ syscall(struct trapframe *tf)
 	 */
 	
 	tf->tf_epc += 4;
+//        kprintf("finished syscall %d\n", callno);
 
 	/* Make sure the syscall code didn't forget to lower spl */
 	KASSERT(curthread->t_curspl == 0);
diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
index d527f61..f7b2628 100644
--- a/kern/conf/conf.kern
+++ b/kern/conf/conf.kern
@@ -330,6 +330,8 @@ file      thread/threadlist.c
 #
 
 file      vm/kmalloc.c
+file	vm/vm.c
+#file	vm/addrspace.c
 
 optofffile dumbvm   vm/addrspace.c
 
@@ -367,7 +369,9 @@ file      vfs/devnull.c
 file      syscall/loadelf.c
 file      syscall/runprogram.c
 file      syscall/time_syscalls.c
-
+file	  syscall/filehandle.c
+file	  syscall/filesyscalls.c
+file	  syscall/procsyscalls.c
 #
 # Startup and initialization
 #
diff --git a/kern/include/addrspace.h b/kern/include/addrspace.h
index 6788e97..fa49d58 100644
--- a/kern/include/addrspace.h
+++ b/kern/include/addrspace.h
@@ -48,6 +48,33 @@ struct vnode;
  * You write this.
  */
 
+struct page{
+
+        vaddr_t virtualAddress;
+        paddr_t physicalAddress;
+	
+
+	//flags
+	int write_flag;
+        int read_flag;
+        int exec_flag;
+	
+
+
+        //make it a linked list since a two level page table is beyond my puny brain
+        struct page* next;
+
+};
+
+/*
+struct regions{
+	vaddr_t region_vbase;
+	vaddr_t region_pbase;
+	size_t page_number;
+};*/
+
+
+
 struct addrspace {
 #if OPT_DUMBVM
         vaddr_t as_vbase1;
@@ -59,9 +86,43 @@ struct addrspace {
         paddr_t as_stackpbase;
 #else
         /* Put stuff here for your VM system */
+	//page_table is the whole table. Ordered in code, static, heap, then stack. just the variable page_table will point to the beginning of the code region
+	struct page *page_table;	
+
+	//the start of the static data
+	struct page *static_region_start;
+
+	//the stack pages
+	struct page *heap_region_start;
+
+	//the heap pages
+	struct page *stack_region_start;
+	
+	//these are for the region that the address space defines
+	vaddr_t code_vbase;
+	size_t code_page_number;
+
+
+	//static region
+	vaddr_t static_vbase;
+	size_t static_page_number;
+	
+	//addresses for the heap and stack
+	vaddr_t heap_start;
+	vaddr_t heap_end;
+
+
+	vaddr_t stack_bottom;
+
+
+
 #endif
 };
 
+
+struct page* pgdir_walk(struct addrspace as, vaddr_t vaddress);
+
+
 /*
  * Functions in addrspace.c:
  *
@@ -111,6 +172,8 @@ int               as_complete_load(struct addrspace *as);
 int               as_define_stack(struct addrspace *as, vaddr_t *initstackptr);
 
 
+
+
 /*
  * Functions in loadelf.c
  *    load_elf - load an ELF user program executable into the current
diff --git a/kern/include/filehandle.h b/kern/include/filehandle.h
new file mode 100644
index 0000000..406d5f9
--- /dev/null
+++ b/kern/include/filehandle.h
@@ -0,0 +1,27 @@
+#ifndef _FILEHANDLE_H_
+#define _FILEHANDLE_H_
+
+#include <vnode.h>
+#include <types.h>
+
+//#define FD_LIMIT 128
+#define FD_LIMIT 12
+struct filehandle 
+{
+	struct vnode *vn;
+	off_t offset;
+	int openflags;
+	int refcnt;
+	struct lock *lk;		
+};
+
+struct filehandle * filehandle_create(struct vnode *vn, off_t offset, int flags);
+
+/*Helper function to search through the file descriptor table for the next
+ * available fd
+ * Implemented in thread.c
+ */
+
+int get_next_aval_fd(struct filehandle **farr, int *fd); 
+
+#endif /*_FILEHANDLE_H_*/
diff --git a/kern/include/kern/proccalls.h b/kern/include/kern/proccalls.h
new file mode 100644
index 0000000..dc304bd
--- /dev/null
+++ b/kern/include/kern/proccalls.h
@@ -0,0 +1,39 @@
+#ifndef PROCCALLS_H_
+#define PROCCALLS_H_
+
+#include <../../../user/include/sys/null.h>
+#include <limits.h>
+#include <types.h>
+#include <../../arch/mips/include/trapframe.h> 
+
+
+struct process{
+        struct thread* thd;
+        int exit_code;
+        pid_t par_pid;
+        bool exit;
+	struct  semaphore* sem;
+};
+
+struct spinlock *proclock;
+
+struct process *proc_tbl[PID_LIMIT];
+
+pid_t find_pid(void);
+
+void proc_create(struct thread *td, pid_t id, pid_t parent_pid);
+
+void enter(void* tf, unsigned long addrs);
+
+void sys_exit(int exitcode);
+
+int sys_fork(struct trapframe *tf, int *retval);
+
+pid_t sys_getpid(void);
+
+int sys_waitpid(pid_t pid, int *status, int options, int *retval);
+
+int sys_execv(const char *program, char **args);
+
+#endif
+
diff --git a/kern/include/lib.h b/kern/include/lib.h
index da04195..352060c 100644
--- a/kern/include/lib.h
+++ b/kern/include/lib.h
@@ -88,7 +88,16 @@
 #define DB_NET         0x200
 #define DB_NETFS       0x400
 #define DB_KMALLOC     0x800
-
+#define DB_SEM	       0x101
+#define DB_LOCK	       0x102		
+#define DB_CV	       0x103
+#define DB_RWLOCK      0x104	
+#define DB_FORK        0x201
+#define DB_READ        0x301
+#define DB_WRITE       0x302
+#define DB_OPEN        0x401
+#define DB_CLOSE       0x402
+#define DB_GETPID      0x202	
 extern uint32_t dbflags;
 
 /*
@@ -191,6 +200,8 @@ void kprintf_bootstrap(void);
 #define DIVROUNDUP(a,b) (((a)+(b)-1)/(b))
 #define ROUNDUP(a,b)    (DIVROUNDUP(a,b)*b)
 
+#define ROUNDDOWN(a,b)  ((a/b)*b)
+
 void random_yielder(uint32_t);
 void random_spinner(uint32_t);
 
diff --git a/kern/include/limits.h b/kern/include/limits.h
index 01684c4..47de8d0 100644
--- a/kern/include/limits.h
+++ b/kern/include/limits.h
@@ -48,5 +48,7 @@
 #define LOGIN_NAME_MAX  __LOGIN_NAME_MAX
 #define OPEN_MAX        __OPEN_MAX
 #define IOV_MAX         __IOV_MAX
+//#define PID_LIMIT 256
+#define PID_LIMIT 64
 
 #endif /* _LIMITS_H_ */
diff --git a/kern/include/synch.h b/kern/include/synch.h
index ac3714b..768fd3f 100644
--- a/kern/include/synch.h
+++ b/kern/include/synch.h
@@ -74,8 +74,10 @@ void V(struct semaphore *);
  */
 struct lock {
         char *lk_name;
-        // add what you need here
-        // (don't forget to mark things volatile as needed)
+        struct wchan *lk_wchan;
+	struct spinlock lk_lock;
+	volatile int lk_used;			//0 for free and 1 for used
+	volatile struct thread *lk_owner;
 };
 
 struct lock *lock_create(const char *name);
@@ -87,8 +89,7 @@ void lock_acquire(struct lock *);
  *                   same time.
  *    lock_release - Free the lock. Only the thread holding the lock may do
  *                   this.
- *    lock_do_i_hold - Return true if the current thread holds the lock; 
- *                   false otherwise.
+ *    lock_do_i_hold - Return true if the current thread holds the lock;                   false otherwise.
  *
  * These operations must be atomic. You get to write them.
  */
@@ -113,8 +114,7 @@ void lock_destroy(struct lock *);
 
 struct cv {
         char *cv_name;
-        // add what you need here
-        // (don't forget to mark things volatile as needed)
+	struct wchan *cv_wchan;
 };
 
 struct cv *cv_create(const char *name);
@@ -143,6 +143,11 @@ void cv_broadcast(struct cv *cv, struct lock *lock);
 
 struct rwlock {
         char *rwlock_name;
+	struct wchan *rwlock_wchan;
+	struct spinlock rwlock_lock;
+	volatile int rwlock_is_write_waiting;
+	volatile int rwlock_readcount;	//Counter for how many readers are in	
+	volatile int rwlock_writerin;	//false: no write thread inside
 };
 
 struct rwlock * rwlock_create(const char *);
diff --git a/kern/include/syscall.h b/kern/include/syscall.h
index befd3d8..3de63d5 100644
--- a/kern/include/syscall.h
+++ b/kern/include/syscall.h
@@ -58,4 +58,48 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
 int sys_reboot(int code);
 int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
 
+/*
+struct process{
+	struct thread* thd;
+	int exit_code;
+	pid_t par_pid;
+	bool exit;
+};
+
+pid_t find_pid(void);
+
+void proc_create(struct thread *td, pid_t id);
+*/
+/*
+ *The file system call declarations
+ */
+
+int sys_open(const char *filename, int flags, int32_t *retval);
+
+int sys_close(int fd); 
+
+int sys_read(int fd, void *buf, size_t buflen, int32_t *retval);
+
+int sys_write(int fd, const void *buf, size_t nbytes, int32_t *retval);
+
+off_t sys_lseek(int fd, off_t pos, int whence, int32_t *retval, int32_t *ret); 
+
+int sys_dup2(int oldfd, int newfd, int32_t *retval); 
+
+int sys___getcwd(char *buf, size_t buflen, int32_t *retval); 
+
+int sys_chdir(const char *pathname); 
+
+int sys_sbrk(intptr_t amount, int *ret);
+/*
+void sys_exit(int exitcode);
+
+int sys_fork(void);
+
+int sys_getpid(void);
+
+int sys_waitpid(pid_t pid, int *status, int options);
+
+int sys_execv(const char *program, char **args);
+*/
 #endif /* _SYSCALL_H_ */
diff --git a/kern/include/test.h b/kern/include/test.h
index 240d583..5ac99c5 100644
--- a/kern/include/test.h
+++ b/kern/include/test.h
@@ -105,7 +105,7 @@ int mallocstress(int, char **);
 int nettest(int, char **);
 
 /* Routine for running a user-level program. */
-int runprogram(char *progname);
+int runprogram(char *progname, char **args, int numargs);
 
 /* Kernel menu system. */
 void menu(char *argstr);
diff --git a/kern/include/thread.h b/kern/include/thread.h
index 86706ca..544e6fc 100644
--- a/kern/include/thread.h
+++ b/kern/include/thread.h
@@ -38,6 +38,7 @@
 
 #include <spinlock.h>
 #include <threadlist.h>
+#include <filehandle.h>
 
 struct addrspace;
 struct cpu;
@@ -112,8 +113,16 @@ struct thread {
 	struct vnode *t_cwd;		/* current working directory */
 
 	/* add more here as needed */
+	int pid;
+	struct filehandle *fd_tbl[FD_LIMIT];
 };
 
+struct semaphore *menu_semaphore;
+
+struct lock *execlock;
+
+//struct thread pid_table[128];
+
 /* Call once during system startup to allocate data structures. */
 void thread_bootstrap(void);
 
diff --git a/kern/include/vm.h b/kern/include/vm.h
index e4e73d0..ecbbcb7 100644
--- a/kern/include/vm.h
+++ b/kern/include/vm.h
@@ -36,6 +36,18 @@
  * You'll probably want to add stuff here.
  */
 
+struct coremap_page{
+
+	vaddr_t virtualAddress;
+	struct addrspace* address;
+	//variable for the state, blog uses page_state_t but that doesn't exist
+	//char* state; //use a string, but maybe numbers would be better....
+	int state;//alright, lets try an int since strings are a pain
+	//bool booted;//nevermind, this variable goes in vm,c
+	int first_block_index;//used to keep track of multi-page allocations, so I can free this page when kfree is called on the first page of this allocation. All pages allocated together will share this value
+	paddr_t physicalAddress;//I think I'll need this for alloc_kpages, for the return statement. I could probably move it to the addrspace struct later when I write it.
+
+};
 
 #include <machine/vm.h>
 
@@ -45,6 +57,13 @@
 #define VM_FAULT_READONLY    2    /* A write to a readonly page was attempted*/
 
 
+#define FIXED	0
+#define FREE	1
+#define CLEAN	2
+#define DIRTY	3
+
+
+
 /* Initialization function */
 void vm_bootstrap(void);
 
@@ -59,5 +78,8 @@ void free_kpages(vaddr_t addr);
 void vm_tlbshootdown_all(void);
 void vm_tlbshootdown(const struct tlbshootdown *);
 
+void freeoneaddress(paddr_t addr);
+int free_core_page_number(void);
+paddr_t page_alloc(int npages);
 
 #endif /* _VM_H_ */
diff --git a/kern/startup/main.c b/kern/startup/main.c
index be4c4b8..4a2c659 100644
--- a/kern/startup/main.c
+++ b/kern/startup/main.c
@@ -1,3 +1,4 @@
+//markstar@buffalo.edu & ivaylopa@buffalo.edu
 /*
  * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
  *	The President and Fellows of Harvard College.
@@ -100,7 +101,7 @@ boot(void)
 	kprintf("%s", harvard_copyright);
 	kprintf("\n");
 
-	kprintf("Put-your-group-name-here's system version %s (%s #%d)\n", 
+	kprintf("ivaylopa@buffalo.edu and markstar@buffalo.edu's system version %s (%s #%d)\n", 
 		GROUP_VERSION, buildconfig, buildversion);
 	kprintf("\n");
 
@@ -128,6 +129,7 @@ boot(void)
 	vfs_setbootfs("emu0");
 
 
+	menu_semaphore = sem_create("menu_sem", 0);
 	/*
 	 * Make sure various things aren't screwed up.
 	 */
diff --git a/kern/startup/menu.c b/kern/startup/menu.c
index 6c71551..b46cee0 100644
--- a/kern/startup/menu.c
+++ b/kern/startup/menu.c
@@ -43,6 +43,7 @@
 #include "opt-synchprobs.h"
 #include "opt-sfs.h"
 #include "opt-net.h"
+#include <synch.h>
 
 /*
  * In-kernel menu and command dispatcher.
@@ -87,23 +88,38 @@ cmd_progthread(void *ptr, unsigned long nargs)
 {
 	char **args = ptr;
 	char progname[128];
-	int result;
+	int result, numargs;
+
+	numargs = (int)nargs;
 
 	KASSERT(nargs >= 1);
 
-	if (nargs > 2) {
-		kprintf("Warning: argument passing from menu not supported\n");
-	}
+//	if (nargs > 2) {
+//		kprintf("Warning: argument passing from menu not supported\n");
+//	}
+
+
+//	if(nargs >= 2){
+//		args[nargs] = NULL;
+//	}
+//	else{
+//		args[1] = NULL;
+//	}
 
-	/* Hope we fit. */
 	KASSERT(strlen(args[0]) < sizeof(progname));
 
 	strcpy(progname, args[0]);
 
-	result = runprogram(progname);
+
+//	for(unsigned long i = 0; i < nargs; i++){
+//		strcpy(realarg, args[i]);
+//	}
+
+	result = runprogram(progname, args, numargs);
 	if (result) {
 		kprintf("Running program %s failed: %s\n", args[0],
 			strerror(result));
+		V(menu_semaphore);
 		return;
 	}
 
@@ -142,6 +158,8 @@ common_prog(int nargs, char **args)
 		return result;
 	}
 
+	P(menu_semaphore);
+
 	return 0;
 }
 
diff --git a/kern/synchprobs/problems.c b/kern/synchprobs/problems.c
index 81d2f0e..44a92d1 100644
--- a/kern/synchprobs/problems.c
+++ b/kern/synchprobs/problems.c
@@ -46,9 +46,50 @@
 // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
 // functions will allow you to do local initialization. They are called at
 // the top of the corresponding driver code.
+static struct cv *male_cv;
+
+static struct cv *female_cv;
+
+static struct cv *match_cv;
+
+static struct lock *male_lock;
+
+static struct lock *female_lock;
+
+static struct lock *match_lock;
+
+int malecount = 0;
+
+int femalecount = 0;
+
+int matchcount = 0;
 
 void whalemating_init() {
-  return;
+	male_cv = cv_create("male_cv");
+	if(male_cv == NULL)
+                panic("Couldn't create male_cv");
+
+	female_cv = cv_create("female_cv");
+	if(female_cv == NULL)
+                panic("Couldn't create female_cv");
+        
+	match_cv = cv_create("match_cv");
+	if(match_cv == NULL)
+		panic("Couldn't create match_cv");
+        
+	male_lock = lock_create("male_lock");
+        if(male_lock == NULL)
+                panic("Couldn't create male_lock");
+        
+	female_lock = lock_create("female_lock");
+        if(female_lock == NULL)
+                panic("Couldn't create female_lock");
+      	
+	match_lock = lock_create("match_lock");
+        if(match_lock == NULL)
+                panic("Couldn't create match_lock");
+
+	return;
 }
 
 // 20 Feb 2012 : GWA : Adding at the suggestion of Nikhil Londhe. We don't
@@ -62,15 +103,35 @@ void
 male(void *p, unsigned long which)
 {
 	struct semaphore * whalematingMenuSemaphore = (struct semaphore *)p;
-  (void)which;
-  
-  male_start();
-	// Implement this function 
-  male_end();
-
+  	(void)which;
+//	male_start();
+	lock_acquire(male_lock);
+	male_start();
+//	kprintf("male %ld starting\n", which);
+	malecount++;
+	cv_signal(match_cv, match_lock);
+//	cv_broadcast(female_cv, male_lock);
+//	cv_broadcast(match_cv, male_lock);
+//	malecount++;
+//	while(!femalecount || !matchcount){
+		cv_wait(male_cv, male_lock);
+//		cv_signal(female_cv, male_lock);
+//        	cv_signal(match_cv, male_lock);
+//		;
+//	}
+//	cv_signal(female_cv, female_lock);
+//	cv_signal(match_cv, match_lock);
+//	kprintf("male %ld mating\n", which);
+//	malecount--;
+//	cv_broadcast(male_cv, male_lock);
+	male_end();
+//	kprintf("male %ld ending\n", which);
+	lock_release(male_lock);
+//	cv_signal(male_cv, male_lock);
+//	male_end();
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // whalemating driver can return to the menu cleanly.
-  V(whalematingMenuSemaphore);
+ 	V(whalematingMenuSemaphore);
   return;
 }
 
@@ -78,12 +139,31 @@ void
 female(void *p, unsigned long which)
 {
 	struct semaphore * whalematingMenuSemaphore = (struct semaphore *)p;
-  (void)which;
-  
-  female_start();
-	// Implement this function 
-  female_end();
-  
+	(void)which;
+//	female_start();
+  	lock_acquire(female_lock);
+	female_start();
+//	kprintf("female %ld starting\n", which);
+        femalecount++;
+	cv_signal(match_cv, match_lock);
+//	cv_broadcast(male_cv, female_lock);
+//        cv_broadcast(match_cv, female_lock);
+//	femalecount++; 
+//       while(!malecount || !matchcount){
+              cv_wait(female_cv, female_lock);
+//		cv_signal(male_cv, female_lock);
+//        	cv_signal(match_cv, female_lock);
+//		;
+//	}
+//	cv_signal(male_cv, male_lock);
+//	cv_signal(match_cv, match_lock);
+//  	kprintf("female %ld mating\n", which);
+//	femalecount--;
+	female_end();
+//	kprintf("female %ld ending\n", which);
+	lock_release(female_lock);
+//	cv_signal(female_cv, female_lock);
+//	female_end();
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // whalemating driver can return to the menu cleanly.
   V(whalematingMenuSemaphore);
@@ -94,12 +174,32 @@ void
 matchmaker(void *p, unsigned long which)
 {
 	struct semaphore * whalematingMenuSemaphore = (struct semaphore *)p;
-  (void)which;
-  
-  matchmaker_start();
-	// Implement this function 
-  matchmaker_end();
-  
+ 	(void)which;
+//	matchmaker_start();
+  	lock_acquire(match_lock);
+	matchmaker_start();
+//	kprintf("%ld match making starting\n", which);
+	matchcount++;
+//	cv_broadcast(male_cv, match_lock);
+//	cv_broadcast(female_cv, match_lock);
+//	matchcount++;
+	while(!malecount || !femalecount){
+		cv_wait(match_cv, match_lock);
+//		cv_signal(male_cv, match_lock);
+//        	cv_signal(female_cv, match_lock);
+//		;
+	}	
+	cv_signal(male_cv, male_lock);
+	cv_signal(female_cv, female_lock);
+//	kprintf("%ld match making\n", which);
+	matchcount--;
+	malecount--;
+	femalecount--;
+	matchmaker_end();
+//	kprintf("%ld match making ending\n", which);
+	lock_release(match_lock);
+//	cv_signal(match_cv, match_lock);
+//	matchmaker_end();
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // whalemating driver can return to the menu cleanly.
   V(whalematingMenuSemaphore);
@@ -136,9 +236,31 @@ matchmaker(void *p, unsigned long which)
 // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
 // functions will allow you to do local initialization. They are called at
 // the top of the corresponding driver code.
+static struct lock *lock_0;
+static struct lock *lock_1;
+static struct lock *lock_2;
+static struct lock *lock_3;
 
-void stoplight_init() {
-  return;
+static struct semaphore *sem_intersect;
+
+void stoplight_init() 
+{
+	lock_0 = lock_create("quadr 0");
+	if(lock_0 == NULL)
+		panic("stoplight: lock_create failed");
+	lock_1 = lock_create("quadr 1");       
+	if(lock_1 == NULL)
+                panic("stoplight: lock_create failed");
+	lock_2 = lock_create("quadr 2");
+        if(lock_2 == NULL)
+                panic("stoplight: lock_create failed");
+	lock_3 = lock_create("quadr 3");
+        if(lock_3 == NULL)
+                panic("stoplight: lock_create failed");
+
+	sem_intersect = sem_create("Intersection semaphore", 3);
+	
+	return;
 }
 
 // 20 Feb 2012 : GWA : Adding at the suggestion of Nikhil Londhe. We don't
@@ -152,34 +274,196 @@ void
 gostraight(void *p, unsigned long direction)
 {
 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
-  (void)direction;
-  
-  // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
-  // stoplight driver can return to the menu cleanly.
-  V(stoplightMenuSemaphore);
-  return;
+	(void)direction;
+
+	P(sem_intersect);
+
+	switch(direction)
+	{
+		case 0:
+		{
+			lock_acquire(lock_0);
+			inQuadrant(0);
+			lock_acquire(lock_3);
+			inQuadrant(3);
+			lock_release(lock_0);
+			leaveIntersection();
+			lock_release(lock_3);
+			break;
+		}
+		
+		case 1: 
+                {
+                        lock_acquire(lock_1);
+                        inQuadrant(1);
+                        lock_acquire(lock_0);
+			inQuadrant(0);
+                        lock_release(lock_1);
+                        leaveIntersection();
+                        lock_release(lock_0);
+                        break;
+                }
+		
+		case 2: 
+                {
+                        lock_acquire(lock_2);
+                        inQuadrant(2);
+                        lock_acquire(lock_1);
+			inQuadrant(1);
+                        lock_release(lock_2);
+                        leaveIntersection();
+                        lock_release(lock_1);
+                        break;
+                }
+		
+		case 3: 
+                {
+                        lock_acquire(lock_3);
+                        inQuadrant(3);
+                        lock_acquire(lock_2);
+			inQuadrant(2);
+                        lock_release(lock_3);
+                        leaveIntersection();
+                        lock_release(lock_2);
+                        break;
+                }
+	}
+	
+	V(sem_intersect);
+	
+	// 08 Feb 2012 : GWA : Please do not change this code. This is so that 
+  	// your stoplight driver can return to the menu cleanly.
+  	V(stoplightMenuSemaphore);
+  	return;
 }
 
 void
 turnleft(void *p, unsigned long direction)
 {
 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
-  (void)direction;
-  
-  // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
-  // stoplight driver can return to the menu cleanly.
-  V(stoplightMenuSemaphore);
-  return;
+  	(void)direction;
+  	
+	P(sem_intersect);
+
+	switch(direction)
+	{
+		case 0:
+		{
+			lock_acquire(lock_0);
+			inQuadrant(0);
+			lock_acquire(lock_3);
+			inQuadrant(3);
+			lock_release(lock_0);
+			lock_acquire(lock_2);
+			inQuadrant(2);
+			lock_release(lock_3);
+			leaveIntersection();
+			lock_release(lock_2);
+			break;
+		}
+		
+		case 1:
+                {
+                        lock_acquire(lock_1);
+                        inQuadrant(1);
+                        lock_acquire(lock_0);
+			inQuadrant(0);
+                        lock_release(lock_1);
+                        lock_acquire(lock_3);
+			inQuadrant(3);
+                        lock_release(lock_0);
+                        leaveIntersection();
+                        lock_release(lock_3);
+                        break;
+                }
+  		
+		case 2:
+                {
+                        lock_acquire(lock_2);
+                        inQuadrant(2);
+                        lock_acquire(lock_1);
+			inQuadrant(1);
+                        lock_release(lock_2);
+                        lock_acquire(lock_0);
+			inQuadrant(0);
+                        lock_release(lock_1);
+                        leaveIntersection();
+                        lock_release(lock_0);
+                        break;
+                }
+  		case 3:
+                {
+                        lock_acquire(lock_3);
+                        inQuadrant(3);
+                        lock_acquire(lock_2);
+			inQuadrant(2);
+                        lock_release(lock_3);
+                        lock_acquire(lock_1);
+			inQuadrant(1);
+                        lock_release(lock_2);
+                        leaveIntersection();
+                        lock_release(lock_1);
+                        break;
+                }
+	}
+	
+	V(sem_intersect);
+
+  	// 08 Feb 2012 : GWA : Please do not change this code. This is so that 
+	// your stoplight driver can return to the menu cleanly.
+  	V(stoplightMenuSemaphore);
+  	return;
 }
 
 void
 turnright(void *p, unsigned long direction)
 {
 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
-  (void)direction;
+  	(void)direction;
+	
+	P(sem_intersect);
+	
+	switch(direction)
+	{
+		case 0:
+		{
+			lock_acquire(lock_0);
+			inQuadrant(0);
+			leaveIntersection();
+			lock_release(lock_0);
+			break;
+		}
 
-  // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
-  // stoplight driver can return to the menu cleanly.
-  V(stoplightMenuSemaphore);
-  return;
+                case 1:
+                {
+                        lock_acquire(lock_1);
+                        inQuadrant(1);
+                        leaveIntersection();
+                        lock_release(lock_1);
+                        break;
+                }
+                case 2:
+                {
+                        lock_acquire(lock_2);
+                        inQuadrant(2);
+                        leaveIntersection();
+                        lock_release(lock_2);
+                        break;
+                }
+                
+		case 3:
+                {
+                        lock_acquire(lock_3);
+                        inQuadrant(3);
+                        leaveIntersection();
+                        lock_release(lock_3);
+                        break;
+                }
+	}
+	
+	V(sem_intersect);
+  	
+	// 08 Feb 2012 : GWA : Please do not change this code. This is so that y	// your stoplight driver can return to the menu cleanly.
+  	V(stoplightMenuSemaphore);
+  	return;
 }
diff --git a/kern/syscall/filehandle.c b/kern/syscall/filehandle.c
new file mode 100644
index 0000000..713af59
--- /dev/null
+++ b/kern/syscall/filehandle.c
@@ -0,0 +1,41 @@
+#include <types.h>
+#include <lib.h>
+#include <thread.h>
+#include <filehandle.h>
+#include <kern/errno.h>
+#include <synch.h>
+
+struct filehandle * filehandle_create(struct vnode *vn, off_t offset, int flags){
+	struct filehandle *fh;
+
+	fh = kmalloc(sizeof(*fh));
+	if(fh == NULL)
+		return NULL;
+	
+	fh->vn = vn;
+	fh->offset = offset;
+	fh->openflags = flags;
+	fh->refcnt = 1;
+//	fh->lk=kmalloc(sizeof(struct lock *));
+//	fh->lk = lock_create("fd_lk");	
+
+	return fh;
+}
+
+int get_next_aval_fd(struct filehandle **farr, int *fd)
+{
+        int count;
+
+        for(count = 0; count < FD_LIMIT; count++)
+        {
+                if(farr[count] == NULL || farr[count] == (struct filehandle *) 0xdeadbeef)
+                {
+                        *fd = count;
+                        return 0;
+                }
+        }
+        //If we get this far then there are no fds available
+        //return an error
+        return EMFILE;
+}
+   
diff --git a/kern/syscall/filesyscalls.c b/kern/syscall/filesyscalls.c
new file mode 100644
index 0000000..b5cb2b0
--- /dev/null
+++ b/kern/syscall/filesyscalls.c
@@ -0,0 +1,404 @@
+#include <types.h>
+#include <lib.h>
+#include <array.h>
+#include <current.h>
+#include <copyinout.h>
+#include <vfs.h>
+#include <vnode.h>
+//#include <syscall.h>
+#include <filehandle.h>
+#include <stat.h>
+#include <kern/errno.h>
+#include <kern/fcntl.h>
+#include <mips/trapframe.h>
+#include <uio.h>
+#include <kern/iovec.h>
+#include <kern/seek.h>
+#include <limits.h>
+#include <synch.h>
+#include <filehandle.h>
+//#include <syscall.h>
+#include <kern/syscall.h>
+//#include <mips/trapframe.h>
+#include <syscall.h>
+
+int sys_open(const char *filename, int flags, int32_t *retval)
+{
+	int result, fd;
+	off_t offset;
+	char path[PATH_MAX];
+	struct filehandle *fh;
+	struct vnode *vn;
+	struct stat *st;
+	size_t length;
+
+	result = get_next_aval_fd(curthread->fd_tbl, &fd);
+	if(result)
+		return result;
+
+	if((flags & O_ACCMODE) == 3)
+		return EINVAL;
+	
+//	path = (char *) kmalloc(sizeof(char)*PATH_MAX);
+
+//	kprintf("copystr again???");
+	result = copyinstr((const_userptr_t) filename, path, PATH_MAX, &length);
+	if(result)
+		return result;
+	
+	result = vfs_open(path, flags, 0, &vn);
+	if(result)
+		return result;
+
+	if(flags & O_APPEND)
+	{
+		st = (struct stat *)kmalloc(sizeof(struct stat));
+		VOP_STAT(vn, st);
+		offset = st->st_size;
+		kfree(st);
+	}
+	else
+		offset = 0;
+
+	flags = flags & O_ACCMODE;
+
+	fh = filehandle_create(vn, offset, flags);
+
+	curthread->fd_tbl[fd] = fh;
+	
+	
+
+	*retval = fd;
+	
+	return 0;
+}
+
+int sys_close(int fd)
+{
+	if(fd < 0 || fd >= FD_LIMIT || curthread->fd_tbl[fd] == NULL || curthread->fd_tbl[fd] ==(struct filehandle *)  0xdeadbeef)
+	{
+		return EBADF;
+	}
+
+//	curthread->fd_tbl[fd]->refcnt -= 1;
+//	vfs_close(curthread->fd_tbl[fd]->vn);
+	if(curthread->fd_tbl[fd]->refcnt == 1)
+	{
+		vfs_close(curthread->fd_tbl[fd]->vn);
+		kfree(curthread->fd_tbl[fd]);
+		curthread->fd_tbl[fd] = NULL;
+	}
+	else{
+//		VOP_DECREF(curthread->fd_tbl[fd]->vn);
+		curthread->fd_tbl[fd]->refcnt = curthread->fd_tbl[fd]->refcnt - 1;
+	}	
+	return 0;
+}
+
+int sys_write(int fd, const void *buf, size_t nbytes, int32_t *retval)
+{
+	int result;
+	struct uio *uio_w;
+	struct iovec *iov_w;
+
+//	kprintf("begin write");
+	
+	void *buf_t;
+//	buf_t = kmalloc(sizeof(*buf)*nbytes);
+//	if(buf_t == NULL){
+//		kfree(buf_t);
+//		return EINVAL;
+//	}	
+
+	if(fd < 0 || fd >= FD_LIMIT || (curthread->fd_tbl[fd] == NULL) || curthread->fd_tbl[fd] == (struct filehandle *) 0xdeadbeef)
+	{
+//		kprintf("%d, %p\n", fd, curthread->fd_tbl[fd]);
+//		kfree(buf_t);
+		return EBADF;
+	}
+
+	if(curthread->fd_tbl[fd]->openflags == O_RDONLY) 
+	{
+//		kfree(buf_t);
+		return EBADF;
+	}		
+
+
+//	lock_acquire(curthread->fd_tbl[fd]->lk);		
+
+	buf_t = kmalloc(sizeof(*buf)*nbytes);
+        if(buf_t == NULL){
+                kfree(buf_t);
+                return EINVAL;
+        }
+
+	
+	iov_w = (struct iovec *)kmalloc(sizeof(struct iovec));
+	result = copyin((const_userptr_t) buf, buf_t, nbytes);//iov_w->iov_ubase, nbytes);
+	if(result)
+	{
+		kfree(iov_w);
+		kfree(buf_t);
+//		lock_release(curthread->fd_tbl[fd]->lk);
+		return result;
+	}
+	iov_w->iov_len = nbytes;
+	iov_w->iov_ubase = (userptr_t)buf;
+//	kprintf("%c", *((char *) iov_w->iov_ubase));
+	uio_w = (struct uio *)kmalloc(sizeof(struct uio));
+
+	uio_w->uio_iov = iov_w;
+	uio_w->uio_iovcnt = 1;
+	uio_w->uio_segflg = UIO_USERSPACE;	
+	uio_w->uio_rw = UIO_WRITE;
+	uio_w->uio_offset = curthread->fd_tbl[fd]->offset;
+	uio_w->uio_resid = nbytes;
+	uio_w->uio_space = curthread->t_addrspace;
+	
+
+	result = VOP_WRITE(curthread->fd_tbl[fd]->vn, uio_w); 
+	if(result)
+	{
+		kfree(iov_w);
+		kfree(uio_w);
+		kfree(buf_t);
+//		lock_release(curthread->fd_tbl[fd]->lk);
+		return result;
+	}	
+	*retval = nbytes - uio_w->uio_resid;
+
+	curthread->fd_tbl[fd]->offset += *retval;
+//	curthread->fd_tbl[fd]->offset = uio_w->uio_offset;
+	
+	kfree(iov_w);
+        kfree(uio_w);
+	kfree(buf_t);
+//	lock_release(curthread->fd_tbl[fd]->lk);
+
+//	kprintf("finished write\n");
+
+	return 0;
+}
+
+
+
+int sys_read(int fd, void *buf, size_t buflen, int32_t *retval)
+{
+        int result;
+        struct uio *uio_r;
+        struct iovec *iov_r;
+
+
+
+        if(fd < 0 || fd >= FD_LIMIT || curthread->fd_tbl[fd] == NULL || curthread->fd_tbl[fd] == (struct filehandle *)0xdeadbeef)
+        {
+                return EBADF;
+        }
+
+        if(curthread->fd_tbl[fd]->openflags == O_WRONLY)
+        {
+                return EBADF;
+        }
+
+//	lock_acquire(curthread->fd_tbl[fd]->lk);
+
+	iov_r = (struct iovec *)kmalloc(sizeof(struct iovec));
+
+//      result = copyin((const_userptr_t) buf, iov_r->iov_ubase, buflen);
+//      if(result)
+//              return result;
+	
+	iov_r->iov_ubase = (userptr_t)buf;
+        iov_r->iov_len = buflen;
+
+	uio_r = (struct uio *)kmalloc(sizeof(struct uio));
+
+        uio_r->uio_iov = iov_r;
+        uio_r->uio_iovcnt = 1;
+        uio_r->uio_segflg = UIO_USERSPACE;
+        uio_r->uio_rw = UIO_READ;
+        uio_r->uio_offset = curthread->fd_tbl[fd]->offset;
+        uio_r->uio_resid = buflen;
+        uio_r->uio_space = curthread->t_addrspace;
+
+
+        result = VOP_READ(curthread->fd_tbl[fd]->vn, uio_r);
+        if(result){
+  //       	lock_release(curthread->fd_tbl[fd]->lk);
+		kfree(uio_r);
+		kfree(iov_r);
+       		return result;
+	}
+        *retval = buflen - uio_r->uio_resid;
+
+	kfree(uio_r);
+	kfree(iov_r);
+
+//	curthread->fd_tbl[fd]->offset = uio_r->uio_offset;
+	curthread->fd_tbl[fd]->offset += *retval;
+
+//	lock_release(curthread->fd_tbl[fd]->lk);
+
+        return 0;
+}
+
+
+int sys_chdir(const char *pathname)
+{
+	char *name;
+//	char name[PATH_MAX];
+	int result = 0;
+	size_t length;
+	name = (char *) kmalloc(sizeof(char)*PATH_MAX);
+
+	result = copyinstr((const_userptr_t)  pathname, name, PATH_MAX, &length); // NULL);
+	if(result)
+	{
+		kfree(name);
+                return result;
+        }
+
+//	kprintf("reached vfs_chdir");
+
+	result = vfs_chdir(name);
+	if(result)
+	{	
+		kfree(name);
+		return result;
+	}
+
+	kfree(name);
+
+	return 0;
+
+} 
+
+int sys___getcwd(char *buf, size_t buflen, int32_t *retval){
+	
+	int result;
+	size_t length;
+	struct uio *cd_uio;
+	struct iovec *cd_iov;
+
+	cd_iov = (struct iovec *)kmalloc(sizeof(struct iovec));
+	cd_uio = (struct uio *)kmalloc(sizeof(struct uio));
+
+	cd_iov->iov_len = buflen;
+
+	cd_uio->uio_iov = cd_iov;	
+	cd_uio->uio_iovcnt = 1;
+	cd_uio->uio_segflg = UIO_USERSPACE;
+	cd_uio->uio_space = curthread->t_addrspace;
+	cd_uio->uio_rw = UIO_READ;
+	cd_uio->uio_resid = buflen;
+	cd_uio->uio_offset = (off_t)0;
+
+	result = vfs_getcwd(cd_uio);
+	if(result){
+		return result;
+	}
+
+	
+
+	result = copyoutstr((const char *) cd_uio->uio_iov->iov_kbase, (userptr_t)buf, buflen, &length);
+	if(result)
+		return result;
+
+	*retval = length;	
+
+	kfree(cd_uio);
+	kfree(cd_iov);
+
+	return 0;
+}
+
+int sys_dup2(int oldfd, int newfd, int32_t *retval)
+{
+	if(oldfd < 0 || newfd < 0 || oldfd >= FD_LIMIT || newfd >= FD_LIMIT || (curthread->fd_tbl[oldfd] == NULL) || curthread->fd_tbl[oldfd] == (struct filehandle *) 0xdeadbeef)
+	{
+		return EBADF;
+	}
+	if(curthread->fd_tbl[newfd] != NULL)
+	{
+		sys_close(newfd); 
+	}
+	
+	curthread->fd_tbl[newfd] = curthread->fd_tbl[oldfd];
+	curthread->fd_tbl[newfd]->refcnt++;
+
+	*retval = newfd;
+	return 0;
+} 
+
+off_t sys_lseek(int fd, off_t pos, int whence, int32_t *retval, int32_t *ret){
+
+	int result;
+	off_t finpos;
+	struct stat *st;
+
+//	kprintf("begin lseel");
+
+	if(fd < 0 || fd >= FD_LIMIT || curthread->fd_tbl[fd] == NULL|| curthread->fd_tbl[fd] == (struct filehandle *) 0xdeadbeef){
+		return EBADF;
+	}
+	
+	if(whence > 2 || whence < 0){ 	
+		return EINVAL;
+	}
+
+//	lock_acquire(curthread->fd_tbl[fd]->lk);
+
+	
+	
+	if(whence == SEEK_SET){
+		finpos = pos;	
+	}
+
+	else if(whence == SEEK_CUR){
+		finpos = pos + curthread->fd_tbl[fd]->offset;
+	}
+
+	else if(whence == SEEK_END){
+		st = (struct stat *)kmalloc(sizeof(struct stat));
+		result = VOP_STAT(curthread->fd_tbl[fd]->vn, st);
+		if(result){
+			kfree(st);
+			return result;
+		}
+		finpos = pos + st->st_size;
+		kfree(st);
+	}
+	else{
+//		lock_release(curthread->fd_tbl[fd]->lk);
+		return EINVAL;
+	}
+	
+	
+
+	if(finpos < 0){
+//		lock_release(curthread->fd_tbl[fd]->lk);
+		return EINVAL;
+	}
+
+//	kprintf("passed the error checking in lseek with the whence %d\n", whence);
+	
+	result = VOP_TRYSEEK(curthread->fd_tbl[fd]->vn, finpos);
+	if(result){
+//		lock_release(curthread->fd_tbl[fd]->lk);
+		return result;
+	}
+
+	curthread->fd_tbl[fd]->offset = finpos;
+	
+	*retval = (uint32_t)((finpos & 0xFFFFFFFF00000000) >> 32);
+
+	*ret = (uint32_t)(finpos & 0x00000000FFFFFFFF);	
+
+//	kfree(st);
+
+//	kprintf("got past VOP_SEEK with result %d and finpos %lld and ret %lld\n", result, finpos, *ret);
+	
+//	lock_release(curthread->fd_tbl[fd]->lk);
+//	kprintf("finished lseek\n");
+	return 0;
+}
diff --git a/kern/syscall/procsyscalls.c b/kern/syscall/procsyscalls.c
new file mode 100644
index 0000000..2ad0ee1
--- /dev/null
+++ b/kern/syscall/procsyscalls.c
@@ -0,0 +1,529 @@
+#include <types.h>
+#include <lib.h>
+#include <kern/proccalls.h>
+#include <array.h>
+#include <current.h>
+#include <copyinout.h>
+#include <vfs.h>
+#include <vnode.h>
+#include <filehandle.h>
+#include <stat.h>
+#include <kern/errno.h>
+#include <kern/fcntl.h>
+#include <mips/trapframe.h>
+#include <uio.h>
+#include <kern/iovec.h>
+#include <kern/seek.h>
+#include <limits.h>
+#include <synch.h>
+#include <filehandle.h>
+#include <addrspace.h>
+#include <vm.h>
+#include <kern/syscall.h>
+#include <syscall.h>
+#include <kern/wait.h>
+#include <spl.h>
+
+
+pid_t sys_getpid(void){
+	return curthread->pid;
+}
+
+int  sys_waitpid(pid_t pid, int *status, int options, int *retval){
+	
+	int result;
+
+
+	if(pid > PID_LIMIT || pid < 1 || proc_tbl[pid] == NULL){
+
+                return ESRCH;
+        }       
+        if((pid == proc_tbl[curthread->pid]->par_pid) || pid == curthread->pid || proc_tbl[pid]->par_pid != curthread->pid){
+//        	if(pid == proc_tbl[curthread->pid]->par_pid){
+//		kprintf("ECHILD\n");
+//		}
+	        return ECHILD;
+        }
+
+	if(options != 0){
+		return EINVAL;
+	}
+	if(status == NULL || status > (int *)0x80000000){
+		return EFAULT;
+	}
+/*	if(pid > PID_LIMIT || pid < 1 || proc_tbl[pid] == NULL){
+		return ESRCH;
+	}
+	if((pid == proc_tbl[curthread->pid]->par_pid) || pid == curthread->pid || proc_tbl[pid]->par_pid != curthread->pid){
+		return ECHILD;
+	}
+*/
+	if(proc_tbl[pid]->exit == false){
+		P(proc_tbl[pid]->sem);
+	}
+
+	result = copyout((const void *) &(proc_tbl[pid]->exit_code), (userptr_t) status, sizeof(int));
+	if(result){
+		return result;
+	}
+
+	*retval = pid;
+
+//	sem_destroy(proc_tbl[pid]->sem);
+
+	kfree(proc_tbl[pid]);
+	proc_tbl[pid] = NULL;
+	return 0;
+	
+}
+
+
+int sys_execv(const char *program, char **args)
+{		
+
+	
+
+        int result, arglen, index, bytenum;
+        char **temparg, *progname;
+	vaddr_t enter, stackptr;
+//	char **copyarg;
+
+//	size_t argsize;
+	size_t realargsize;
+	 
+	int argc = 0;
+//	if(!(result = strlen(program)))
+//		return EISDIR;a
+
+	struct  vnode *v;
+
+	if (program == NULL || args == NULL){
+		return EFAULT;
+	}
+
+//	copyarg = (char **) kmalloc(4096);
+
+	progname = (char *)kmalloc(PATH_MAX);
+	result = copyinstr((const_userptr_t)program, progname, PATH_MAX, &realargsize);
+	if(result){
+		kfree(progname);
+		return result;
+	}
+	if(realargsize == 1){
+		kfree(progname);
+		return EINVAL;
+	}
+
+//	while(args[argc] != NULL){
+		
+//		result = copyin(args + index
+
+//		argc++;
+//	}
+
+//	temparg = (char **)kmalloc(sizeof(char*) * (argc + 1));
+
+	temparg = (char **) kmalloc(sizeof(char **));	
+	//copy the whole argument array first in here, as say Doug
+	result = copyin((const_userptr_t) args, temparg, sizeof(char **));
+	if(result){
+		kfree(progname);
+		kfree(temparg);
+		return EINVAL;
+	}
+
+//	for(index = 0; index <  argc; index++){
+//		if((argsize = strlen(args[index])) > ARG_MAX){
+//			return E2BIG;
+//		}
+//		temparg[index] = (char *)kmalloc(ARG_MAX);
+//		result = copyinstr((const_userptr_t)args[index], temparg[index], ARG_MAX, NULL);
+//		if(result){
+//			if(result == ENAMETOOLONG)
+//				return E2BIG;
+//			return result;
+//		}
+//	}
+
+//	now loop through the arg array and copy in each entry now that the whole array was copied in already. See Ivo? This is what Doug meant.
+	index = 0;
+	while(args[index] != NULL){
+		//allocate an entry into the copied in argument array and I don't know how big it is so it's of size PATH_MAX
+		temparg[index] = (char *) kmalloc(sizeof(char) * PATH_MAX);
+
+		//copy the argument into the new array
+		result = copyinstr((const_userptr_t) args[index], temparg[index], PATH_MAX, &realargsize);
+
+		if(result){
+			for(int i = 0; i < index; i++){
+				kfree(temparg[i]);
+			}
+			kfree(temparg);
+			kfree(progname);
+			return EFAULT;
+		}
+
+		index = index + 1;
+//		temparg[index] = NULL;
+	}
+
+	temparg[index] = NULL;
+
+	/* Open the file. */
+        result = vfs_open(progname, O_RDONLY, 0, &v);
+        kfree(progname);
+	if (result) {
+		for(int i = 0; i < index; i++){
+                      kfree(temparg[i]);
+                }
+		kfree(temparg);
+                return result;
+        }
+
+	if(curthread->t_addrspace != NULL){
+		as_destroy(curthread->t_addrspace);
+	}
+//	curthread->t_addrspace = NULL;
+
+
+        /* Create a new address space. */
+        curthread->t_addrspace = as_create();
+        if (curthread->t_addrspace==NULL) {
+                vfs_close(v);
+		for(int i = 0; i < index; i++){
+			kfree(temparg[i]);
+                }
+
+		kfree(temparg);
+                return ENOMEM;
+        } 
+
+        /* Activate it. */
+        as_activate(curthread->t_addrspace);
+        
+	/* Load the executable. */
+        result = load_elf(v, &enter);
+        if (result) {
+                /* thread_exit destroys curthread->t_addrspace */
+                vfs_close(v);
+		for(int i = 0; i < index; i++){
+                                kfree(temparg[i]);
+                        }
+
+		kfree(temparg);
+                return result;
+        }
+
+        /* Done with the file now. */
+        vfs_close(v);
+
+        /* Define the user stack in the address space */
+        result = as_define_stack(curthread->t_addrspace, &stackptr);
+        if (result) {
+                /* thread_exit destroys curthread->t_addrspace */
+		for(int i = 0; i < index; i++){
+                                kfree(temparg[i]);
+                        }
+                kfree(temparg);
+
+		return result;
+        }
+
+
+
+//	if(argc == 1){
+//                temparg[1] = NULL;
+//        }
+//        else{
+//                tempargs[numargs] = NULL;
+//        }
+
+
+        
+//      int totallength;
+
+
+//        temparg = (char **)kmalloc(sizeof(char*) * numargs);
+
+	argc = index;
+
+        for(index = 0, bytenum = 0; temparg[index] != NULL; index++){
+                arglen = strlen(temparg[index])+1; //adding the 1 so I can have it be null terminated, as said on piazza
+                bytenum = arglen; //arglen is the size of the arg, with no 0s
+                bytenum = (4 - (bytenum % 4));//bytenum is the number of 0s needed to pad the argument on the stack
+                char* onearg = kmalloc(sizeof(bytenum+arglen));//onearg should be bigger then the argument for the null terminating 0s
+                onearg = kstrdup(temparg[index]);
+                for(int i = 0; i < (bytenum + arglen); i++){
+                        if(i < arglen){
+                                onearg[i] = temparg[index][i];
+                        }
+                        else{
+                                onearg[i] = '\0';
+                        }
+                } //onearg is now the entire argument, with padded 0s, that will be put on the stack
+                result = strlen(onearg);
+                stackptr -= (bytenum + arglen);
+                result = copyout((const void *)onearg, (userptr_t)stackptr, (size_t)(bytenum+arglen)); //puts the current arg, with padding, onto the stack
+                if(result){
+			for(int i = 0; i < argc; i++){
+                                kfree(temparg[i]);
+                        }
+			kfree(onearg);
+			kfree(temparg);
+			return result;
+		}
+//              totallength = totallength + bytenum + argnum;
+//              temparg[index] = onearg;
+		kfree(temparg[index]);
+                temparg[index] = (char *)stackptr;
+                kfree(onearg);
+        }
+
+
+	argc = index;
+
+//	        result = sizeof(char*);
+        for(; index >= 0; index--){//index < 0; index--){
+                stackptr = stackptr - 4;
+                if(temparg[index] != NULL){
+                      result = copyout((const void *)(temparg+index), (userptr_t)stackptr, (sizeof(char *)));
+//		      result = copyout((const void *)(temparg[index]), (userptr_t)stackptr, (sizeof(char*)));  
+                      if(result) {
+				for(int i = 0; i < argc; i++){
+                        	        kfree(temparg[i]);
+                	        }
+				
+				kfree(temparg);
+                                return result;
+                        }
+                }
+        }
+
+//	for(int i = 0; i < argc; i++){
+//                    kfree(temparg[i]);
+//        }
+
+	kfree(temparg);
+
+	/* Warp to user mode. */
+        enter_new_process(argc /*argc*/, (userptr_t)stackptr /*userspace addr of argv*/, stackptr, enter);
+
+        /* enter_new_process does not return. */
+        panic("enter_new_process returned\n");
+        return EINVAL;
+
+}
+
+int sys_fork(struct trapframe *tf, int *retval){
+
+	struct trapframe *child_tf;	
+	int result;
+	struct thread *child;
+	struct addrspace *address_child;
+
+//	kprintf("\n");
+
+//	int temp = free_core_page_number();
+//        kprintf("\n number of core map pages is %d\n", temp);
+
+
+	child_tf = kmalloc(sizeof(struct trapframe));
+        if(child_tf == NULL){
+		kfree(child_tf);
+                return ENOMEM;
+        }
+
+
+
+	result = as_copy(curthread->t_addrspace, &address_child);
+	if(result){
+		
+		kfree(child_tf);
+		return ENOMEM; 
+	}
+	
+	
+	*child_tf = *tf;
+
+//	splraise(IPL_NONE, IPL_HIGH);
+	
+
+//	kprintf("\n");
+
+
+//	I'll just make thread_fork do the rest of the work because it's hard to synch this stuff
+	result = thread_fork("Brat", enter, (struct trapframe *) child_tf, (unsigned long) address_child, &child);
+	if(result){
+		kfree(child_tf);
+		return ENOMEM;
+	}
+
+//	kprintf("\n");
+
+//	proc_create(child, child->pid, curthread->pid);
+
+//	kprintf("\n");
+
+	*retval = child->pid;
+
+//	spllower(IPL_HIGH, IPL_NONE);
+
+//	kprintf("\n");
+
+	return 0;
+}
+
+
+void enter(void* tf, unsigned long addrs){
+
+	struct trapframe new_tf;
+	struct addrspace *address;
+
+	new_tf = *(struct trapframe *)tf;
+	new_tf.tf_v0 = 0;
+	new_tf.tf_a3 = 0;
+	new_tf.tf_epc += 4;
+
+	address = (struct addrspace *) addrs;
+	curthread->t_addrspace = address;
+	as_activate(address);	
+		
+	mips_usermode(&new_tf);
+}
+
+void sys_exit(int exitcode){
+	int i;
+	if(curthread->pid != 1 && proc_tbl[proc_tbl[curthread->pid]->par_pid]->exit == false){
+//		if(proc_tbl[curthread->pid] == NULL){
+//			kprintf("the process with pid %d\n", curthread->pid);
+//		}
+		proc_tbl[curthread->pid]->exit_code = _MKWAIT_EXIT(exitcode);
+		proc_tbl[curthread->pid]->exit = true;
+		V(proc_tbl[curthread->pid]->sem);
+	}	
+	else{
+		sem_destroy(proc_tbl[curthread->pid]->sem);
+		
+		for(i = 0; i < FD_LIMIT; i++)
+		{
+			sys_close(i);
+			
+		}
+		kfree(proc_tbl[curthread->pid]);
+		proc_tbl[curthread->pid] = NULL;
+		if(curthread->pid == 1){
+			V(menu_semaphore);
+		}
+	}
+
+	thread_exit();
+}
+
+
+pid_t find_pid(void){
+	int count;
+	for(count = 2; count < PID_LIMIT; count++){
+		if(proc_tbl[count] == NULL){
+			return (pid_t)count;
+		}
+
+	}
+	return -2;
+}
+
+void proc_create(struct thread *td, pid_t id, pid_t parent_pid){
+	struct process *proc;
+	struct semaphore *sema;
+	proc = (struct process *) kmalloc(sizeof(struct process));
+	proc->exit = false;
+	proc->exit_code = 0;
+	proc->thd = td;
+	sema = sem_create("child", 0);
+	proc->sem = sema;
+	proc->par_pid = parent_pid;
+	proc_tbl[id] = proc;
+}
+
+int sys_sbrk(intptr_t amount, int *ret){
+
+	
+	struct addrspace *addr = curthread->t_addrspace;
+	vaddr_t heap_end = addr->heap_end;
+	vaddr_t heap_start = addr->heap_start;
+	vaddr_t new_heap_end;
+
+	if(amount == 0){
+		*ret = heap_end;
+		return 0;
+	}
+
+	if((amount < 0) && ((int)(heap_end - heap_start) < (0 - amount))){
+		return EINVAL;
+	}
+
+	if(heap_end + amount < heap_start){
+		*ret = -1;
+		return EINVAL;
+	}
+
+	new_heap_end = heap_end + amount;
+
+	if(new_heap_end >= addr->stack_region_start->virtualAddress){
+		*ret = -1;
+		return ENOMEM;
+	}
+
+	struct page* last_heap_page = addr->heap_region_start;
+	while(last_heap_page->next != NULL){
+		last_heap_page = last_heap_page->next;
+	}
+
+	if(new_heap_end > (last_heap_page->virtualAddress + PAGE_SIZE)){
+
+		if((amount/PAGE_SIZE) > free_core_page_number()){
+			*ret = -1;
+			return ENOMEM;
+		}
+
+		while(new_heap_end > (last_heap_page->virtualAddress + PAGE_SIZE)){
+			last_heap_page->next = (struct page*)kmalloc(sizeof(struct page));
+			last_heap_page->next->virtualAddress = last_heap_page->virtualAddress + PAGE_SIZE;
+
+			last_heap_page->next->write_flag = last_heap_page->write_flag;
+			last_heap_page->next->read_flag = last_heap_page->read_flag;
+			last_heap_page->next->exec_flag = last_heap_page->exec_flag;
+						
+			last_heap_page = last_heap_page->next;
+			
+			last_heap_page->physicalAddress = page_alloc(1);
+	
+			last_heap_page->next = NULL;
+		}
+		*ret = heap_end;
+		curthread->t_addrspace->heap_end += amount;
+	}
+	else if(new_heap_end < last_heap_page->virtualAddress){
+
+//		if((int)(heap_end - heap_start) < (0 - amount)){
+//			return EINVAL;
+//		}		
+
+		while(new_heap_end < last_heap_page->virtualAddress){
+			last_heap_page = addr->heap_region_start;
+			while(last_heap_page->next->next != NULL){
+				last_heap_page = last_heap_page->next;
+			}
+			freeoneaddress(last_heap_page->next->physicalAddress);
+			kfree(last_heap_page->next);
+			last_heap_page->next = NULL;
+		}
+		*ret = heap_end;
+		curthread->t_addrspace->heap_end -= amount;
+	}
+	else if((new_heap_end > last_heap_page->virtualAddress) && (new_heap_end < (last_heap_page->virtualAddress + PAGE_SIZE))){
+		*ret = heap_end;
+		curthread->t_addrspace->heap_end += amount;
+	}
+
+	return 0;
+}
diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
index a6f45c8..01d5fe6 100644
--- a/kern/syscall/runprogram.c
+++ b/kern/syscall/runprogram.c
@@ -44,7 +44,10 @@
 #include <vfs.h>
 #include <syscall.h>
 #include <test.h>
-
+#include <kern/proccalls.h>
+#include <synch.h>
+#include <limits.h>
+#include <copyinout.h>
 /*
  * Load program "progname" and start running it in usermode.
  * Does not return except on error.
@@ -52,11 +55,28 @@
  * Calls vfs_open on progname and thus may destroy it.
  */
 int
-runprogram(char *progname)
+runprogram(char *progname, char **args, int numargs)
 {
 	struct vnode *v;
 	vaddr_t entrypoint, stackptr;
-	int result;
+	int result, r, index, bytenum;
+//	char **temparg;
+	
+
+	struct vnode *in_vn;
+        char *in = kstrdup("con:");
+        struct vnode *out_vn;
+        char *out = kstrdup("con:");
+        struct vnode *er_vn;
+        char *er = kstrdup("con:");
+
+
+//	if(proclock == NULL){
+//		spinlock_init(proclock);
+//	}
+
+
+//	kprintf("entered runprongram\n");
 
 	/* Open the file. */
 	result = vfs_open(progname, O_RDONLY, 0, &v);
@@ -76,7 +96,7 @@ runprogram(char *progname)
 
 	/* Activate it. */
 	as_activate(curthread->t_addrspace);
-
+//	kprintf("about to load\n");
 	/* Load the executable. */
 	result = load_elf(v, &entrypoint);
 	if (result) {
@@ -87,16 +107,147 @@ runprogram(char *progname)
 
 	/* Done with the file now. */
 	vfs_close(v);
-
+//	kprintf("done\n");
 	/* Define the user stack in the address space */
 	result = as_define_stack(curthread->t_addrspace, &stackptr);
 	if (result) {
 		/* thread_exit destroys curthread->t_addrspace */
 		return result;
 	}
+//	kprintf("opening?\n");
+
+
+//	if(curthread->fd_tbl[0] == NULL){
+		r = vfs_open(in, O_RDONLY, 0, &in_vn);
+		if(r) {
+			return EINVAL;
+		}
+		curthread->fd_tbl[0] = (struct filehandle *)kmalloc(sizeof(struct filehandle));
+		curthread->fd_tbl[0]->vn = in_vn;
+		curthread->fd_tbl[0]->openflags = O_RDONLY;
+		curthread->fd_tbl[0]->offset = 0;
+		curthread->fd_tbl[0]->refcnt = 1;
+//		curthread->fd_tbl[0]->lk = lock_create("input");
+
+		r = vfs_open(out, O_WRONLY, 0, &out_vn);
+		if(r) {
+			return EINVAL;
+		}
+
+		curthread->fd_tbl[1] = (struct filehandle *)kmalloc(sizeof(struct filehandle));
+		curthread->fd_tbl[1]->vn = out_vn;
+		curthread->fd_tbl[1]->openflags = O_WRONLY;
+		curthread->fd_tbl[1]->offset = 0;
+		curthread->fd_tbl[1]->refcnt = 1;
+//		curthread->fd_tbl[1]->lk = lock_create("output");
+
+		r = vfs_open(er, O_WRONLY, 0, &er_vn);
+		if(r) {
+			return EINVAL;
+		}
+
+		curthread->fd_tbl[2] = (struct filehandle *)kmalloc(sizeof(struct filehandle));
+		curthread->fd_tbl[2]->vn = er_vn;
+		curthread->fd_tbl[2]->openflags = O_WRONLY;
+		curthread->fd_tbl[2]->offset = 0;
+		curthread->fd_tbl[2]->refcnt = 1;
+//		curthread->fd_tbl[2]->lk = lock_create("err");
+//	}
+
+
+
+
+	struct process *proc;
+	struct semaphore *sema;
+	proc = (struct process *) kmalloc(sizeof(struct process));
+	curthread->pid = 1;
+        proc->exit = false;
+        proc->exit_code = 0;
+        proc->thd = curthread;
+        sema = sem_create("first_thread", 0);
+        proc->sem = sema;
+        proc->par_pid = 0;
+        proc_tbl[1] = proc;
+
+
+	if(numargs == 1){
+		args[1] = NULL;
+	}
+	else{
+		args[numargs] = NULL;
+	}
+
+	
+	int arglen;
+//	int totallength;
+
+
+//	temparg = (char **)kmalloc(sizeof(char*) * numargs);
+		
+	for(index = 0, bytenum = 0; args[index] != NULL; index++){
+		arglen = strlen(args[index])+1; //adding the 1 so I can have it be null terminated, as said on piazza
+		bytenum = arglen; //arglen is the size of the arg, with no 0s
+		bytenum = (4 - (bytenum % 4));//bytenum is the number of 0s needed to pad the argument on the stack
+		char* onearg = kmalloc(sizeof(bytenum+arglen));//onearg should be bigger then the argument for the null terminating 0s
+		onearg = kstrdup(args[index]);
+		for(int i = 0; i < (bytenum + arglen); i++){
+			if(i < arglen){
+				onearg[i] = args[index][i];
+			}
+			else{
+				onearg[i] = '\0';
+			}
+		} //onearg is now the entire argument, with padded 0s, that will be put on the stack
+		result = strlen(onearg);
+		stackptr -= (bytenum + arglen);
+		result = copyout((const void *)onearg, (userptr_t)stackptr, (size_t)(bytenum+arglen)); //puts the current arg, with padding, onto the stack
+		if(result){return result;}
+//		totallength = totallength + bytenum + argnum;
+//		temparg[index] = onearg;
+		args[index] = (char *)stackptr;
+		kfree(onearg);
+	}
+
+	
+	result = sizeof(char*);
+	for(index = numargs; index >= 0; index--){//index < 0; index--){
+		stackptr = stackptr - 4;
+		if(args[index] != NULL){	
+			result = copyout((const void *)(args+index), (userptr_t)stackptr, (sizeof(char *)));	
+			if(result) {
+				return result;
+			}
+		}
+	}	
+
+		//at this point temparg should be a string array with each padded 
+		//argument at the appropriate index, name at 0 and so on
+		//and totallength is the length of all padded arguments
+/*	char* karg = (char *)kmalloc(sizeof(char) * totallength); //this is making an array to hold one arg char at each index
+	
+	//this loop should place each arg character from the temparg string array in the correct order into the char array
+	int argindex = 0;
+	
+	for(index  = 0; index < numargs; index++){
+		for(int i = 0; i < strlen(temparg[index]); i++){
+			karg[argindex] = temparg[index][i];
+			argindex++;	
+		}
+	}
+	//karg hopefully has all of the chars, in the correct order, that make up the arguments, including the padding 0s
+	
+	stackptr = stackptr - totallength;
+	result = copyout((const void *)temparg
+
+*/	
+	
+	
+	
+
+	
 
 	/* Warp to user mode. */
-	enter_new_process(0 /*argc*/, NULL /*userspace addr of argv*/,
+	enter_new_process(numargs /*argc*/, (userptr_t)stackptr /*userspace addr of argv*/,
 			  stackptr, entrypoint);
 	
 	/* enter_new_process does not return. */
diff --git a/kern/thread/synch.c b/kern/thread/synch.c
index 9a7468c..c488b4d 100644
--- a/kern/thread/synch.c
+++ b/kern/thread/synch.c
@@ -163,7 +163,17 @@ lock_create(const char *name)
                 return NULL;
         }
         
-        // add stuff here as needed
+
+	lock->lk_wchan = wchan_create(lock->lk_name);
+        if (lock->lk_wchan == NULL) {
+                kfree(lock->lk_name);
+                kfree(lock);
+                return NULL;
+        }
+
+	lock->lk_used = 0;
+        spinlock_init(&lock->lk_lock);
+	lock->lk_owner = NULL; 
         
         return lock;
 }
@@ -173,8 +183,10 @@ lock_destroy(struct lock *lock)
 {
         KASSERT(lock != NULL);
 
-        // add stuff here as needed
-        
+	
+	spinlock_cleanup(&lock->lk_lock);
+        wchan_destroy(lock->lk_wchan);
+
         kfree(lock->lk_name);
         kfree(lock);
 }
@@ -182,27 +194,51 @@ lock_destroy(struct lock *lock)
 void
 lock_acquire(struct lock *lock)
 {
-        // Write this
+        KASSERT(lock != NULL);
+	
+	KASSERT(curthread->t_in_interrupt == false);
 
-        (void)lock;  // suppress warning until code gets written
+	spinlock_acquire(&lock->lk_lock);
+/*
+ *	Make sure the current thread does not already hold the lock. If it does 
+ *	panic.
+ */
+	if(lock_do_i_hold(lock) == true)
+	{
+		panic("Trying to aquire lock that that you already hold");
+	}
+	
+	while(lock->lk_used)
+	{
+		wchan_lock(lock->lk_wchan);
+		spinlock_release(&lock->lk_lock);
+		wchan_sleep(lock->lk_wchan);
+				
+		spinlock_acquire(&lock->lk_lock);
+	}
+	KASSERT(lock->lk_used == false);
+	lock->lk_used = true;
+	lock->lk_owner = curthread;
+	spinlock_release(&lock->lk_lock);
 }
 
 void
 lock_release(struct lock *lock)
 {
-        // Write this
+        KASSERT(lock != NULL);
+	spinlock_acquire(&lock->lk_lock);
 
-        (void)lock;  // suppress warning until code gets written
+	lock->lk_used = false;
+	lock->lk_owner = NULL;
+	wchan_wakeone(lock->lk_wchan);
+
+	spinlock_release(&lock->lk_lock);
 }
 
 bool
 lock_do_i_hold(struct lock *lock)
 {
-        // Write this
-
-        (void)lock;  // suppress warning until code gets written
-
-        return true; // dummy until code gets written
+        return lock->lk_owner == curthread;
 }
 
 ////////////////////////////////////////////////////////////
@@ -226,8 +262,14 @@ cv_create(const char *name)
                 return NULL;
         }
         
-        // add stuff here as needed
-        
+ 	cv->cv_wchan = wchan_create(cv->cv_name);
+        if (cv->cv_wchan == NULL) {
+                kfree(cv->cv_name);
+                kfree(cv);
+                return NULL;
+        }
+     
+ 
         return cv;
 }
 
@@ -236,7 +278,7 @@ cv_destroy(struct cv *cv)
 {
         KASSERT(cv != NULL);
 
-        // add stuff here as needed
+	wchan_destroy(cv->cv_wchan);
         
         kfree(cv->cv_name);
         kfree(cv);
@@ -245,23 +287,142 @@ cv_destroy(struct cv *cv)
 void
 cv_wait(struct cv *cv, struct lock *lock)
 {
-        // Write this
-        (void)cv;    // suppress warning until code gets written
-        (void)lock;  // suppress warning until code gets written
+	wchan_lock(cv->cv_wchan);
+	lock_release(lock);
+
+	wchan_sleep(cv->cv_wchan);
+
+	lock_acquire(lock);
 }
 
 void
 cv_signal(struct cv *cv, struct lock *lock)
 {
-        // Write this
-	(void)cv;    // suppress warning until code gets written
-	(void)lock;  // suppress warning until code gets written
+	(void) lock;			//Suppress warning
+      	wchan_wakeone(cv->cv_wchan);
 }
 
 void
 cv_broadcast(struct cv *cv, struct lock *lock)
 {
-	// Write this
-	(void)cv;    // suppress warning until code gets written
-	(void)lock;  // suppress warning until code gets written
+	(void) lock;			//Suppress warning
+	wchan_wakeall(cv->cv_wchan);
+}
+
+struct rwlock *
+ rwlock_create(const char *name)
+{
+	struct rwlock *rwlock;
+
+	rwlock = kmalloc(sizeof(struct rwlock));
+	if(rwlock == NULL)
+	{
+		return NULL;
+	}
+
+	rwlock->rwlock_name = kstrdup(name);
+	if(rwlock->rwlock_name == NULL)
+	{
+		kfree(rwlock);
+		return NULL;
+	}
+
+	rwlock->rwlock_wchan = wchan_create(rwlock->rwlock_name);
+	if(rwlock->rwlock_wchan == NULL)
+	{
+		kfree(rwlock->rwlock_name);
+		kfree(rwlock);
+		return NULL;
+	}
+
+	spinlock_init(&rwlock->rwlock_lock);
+	rwlock->rwlock_readcount = 0;
+	rwlock->rwlock_writerin = false;
+	rwlock->rwlock_is_write_waiting = false;
+
+	return rwlock;
+}
+
+void rwlock_destroy(struct rwlock *rwlock)
+{
+	KASSERT(rwlock != NULL);
+
+	spinlock_cleanup(&rwlock->rwlock_lock);
+	wchan_destroy(rwlock->rwlock_wchan);
+	kfree(rwlock->rwlock_name);
+	kfree(rwlock);	
+}
+
+void rwlock_acquire_read(struct rwlock *rwlock)
+{
+	KASSERT(rwlock != NULL);
+
+	KASSERT(curthread->t_in_interrupt == false);
+
+	spinlock_acquire(&rwlock->rwlock_lock);
+
+	while(rwlock->rwlock_writerin || rwlock->rwlock_is_write_waiting)
+	{
+		wchan_wakeone(rwlock->rwlock_wchan);
+		wchan_lock(rwlock->rwlock_wchan);
+		spinlock_release(&rwlock->rwlock_lock);
+		wchan_sleep(rwlock->rwlock_wchan);
+		spinlock_acquire(&rwlock->rwlock_lock);
+	}
+
+	
+	KASSERT(rwlock->rwlock_writerin == false);
+
+	rwlock->rwlock_readcount++;
+	
+	wchan_wakeone(rwlock->rwlock_wchan);
+
+	spinlock_release(&rwlock->rwlock_lock);	
+}
+
+void rwlock_release_read(struct rwlock *rwlock)
+{
+	KASSERT(rwlock != NULL);
+	spinlock_acquire(&rwlock->rwlock_lock);
+
+	rwlock->rwlock_readcount--;
+	
+	if(rwlock->rwlock_readcount == 0)
+		wchan_wakeone(rwlock->rwlock_wchan);
+
+	spinlock_release(&rwlock->rwlock_lock);
+}
+
+void rwlock_acquire_write(struct rwlock *rwlock)
+{
+	KASSERT(rwlock != NULL);
+
+	KASSERT(curthread->t_in_interrupt == false);
+
+	spinlock_acquire(&rwlock->rwlock_lock);
+	while(rwlock->rwlock_writerin || (rwlock->rwlock_readcount != 0))
+	{
+		rwlock->rwlock_is_write_waiting = true;
+		wchan_lock(rwlock->rwlock_wchan);
+		spinlock_release(&rwlock->rwlock_lock);
+		wchan_sleep(rwlock->rwlock_wchan);
+		spinlock_acquire(&rwlock->rwlock_lock);
+	}
+
+	KASSERT((rwlock->rwlock_writerin == false) &&
+		 (rwlock->rwlock_readcount == 0));
+
+	rwlock->rwlock_writerin = true;
+	rwlock->rwlock_is_write_waiting = false;
+	spinlock_release(&rwlock->rwlock_lock);
+}
+
+void rwlock_release_write(struct rwlock *rwlock)
+{
+	KASSERT(rwlock != NULL);
+	spinlock_acquire(&rwlock->rwlock_lock);
+
+	rwlock->rwlock_writerin = false;
+	wchan_wakeone(rwlock->rwlock_wchan);
+	spinlock_release(&rwlock->rwlock_lock);
 }
diff --git a/kern/thread/thread.c b/kern/thread/thread.c
index e7235e3..7e794d0 100644
--- a/kern/thread/thread.c
+++ b/kern/thread/thread.c
@@ -47,7 +47,10 @@
 #include <addrspace.h>
 #include <mainbus.h>
 #include <vnode.h>
-
+#include <kern/syscall.h>
+#include <kern/proccalls.h>
+#include <syscall.h>
+//#include <kern/proccalls.h>
 #include "opt-synchprobs.h"
 #include "opt-defaultscheduler.h"
 
@@ -109,6 +112,8 @@ thread_checkstack(struct thread *thread)
 	}
 }
 
+
+
 /*
  * Create a thread. This is used both to create a first thread
  * for each CPU and to create subsequent forked threads.
@@ -153,7 +158,8 @@ thread_create(const char *name)
 	thread->t_cwd = NULL;
 
 	/* If you add to struct thread, be sure to initialize here */
-
+	thread->pid = find_pid();
+	
 	return thread;
 }
 
@@ -381,6 +387,8 @@ thread_bootstrap(void)
 	curthread->t_cpu = curcpu;
 	curcpu->c_curthread = curthread;
 
+
+	execlock = lock_create("execv lock");
 	/* Done */
 }
 
@@ -472,7 +480,7 @@ thread_make_runnable(struct thread *target, bool already_have_lock)
  * ENTRYPOINT. DATA1 and DATA2 are passed to ENTRYPOINT.
  *
  * The new thread is given no address space (the caller decides that)
- * but inherits its current working directory from the caller. It will
+	* but inherits its current working directory from the caller. It will
  * start on the same CPU as the caller, unless the scheduler
  * intervenes first.
  */
@@ -504,6 +512,17 @@ thread_fork(const char *name,
 	/* Thread subsystem fields */
 	newthread->t_cpu = curthread->t_cpu;
 
+	for(int i=0; i<FD_LIMIT; i++){  
+		if(curthread->fd_tbl[i]!=NULL && (curthread->fd_tbl[i] != (struct filehandle *)0xdeadbeef)){
+			curthread->fd_tbl[i]->refcnt++;// = curthread->fd_tbl[i]->refcnt+1;
+			newthread->fd_tbl[i] = curthread->fd_tbl[i];//(struct filehandle*)kmalloc(sizeof(struct filehandle));
+//			VOP_INCREF(curthread->fd_tbl[i]->vn);
+//			newthread->fd_tbl[i] = curthread->fd_tbl[i];
+//			memcpy(newthread->fd_tbl[i], curthread->fd_tbl[i], sizeof(struct filehandle));
+		}
+	}
+
+
 	/* VM fields */
 	/* do not clone address space -- let caller decide on that */
 
@@ -523,6 +542,24 @@ thread_fork(const char *name,
 	/* Set up the switchframe so entrypoint() gets called */
 	switchframe_init(newthread, entrypoint, data1, data2);
 
+
+
+	if(proclock == NULL){
+		proclock = kmalloc(sizeof(*proclock));
+		spinlock_init(proclock);
+	}
+
+	spinlock_acquire(proclock);
+
+	newthread->pid = find_pid();
+
+        proc_create(newthread, newthread->pid, curthread->pid);
+
+
+	spinlock_release(proclock);
+
+//	kprintf("a new thread has been forked with pid %d?\n", newthread->pid);
+
 	/* Lock the current cpu's run queue and make the new thread runnable */
 	thread_make_runnable(newthread, false);
 
@@ -1228,3 +1265,4 @@ interprocessor_interrupt(void)
 	curcpu->c_ipi_pending = 0;
 	spinlock_release(&curcpu->c_ipi_lock);
 }
+
diff --git a/kern/vm/addrspace.c b/kern/vm/addrspace.c
index 302fa7b..0b759ed 100644
--- a/kern/vm/addrspace.c
+++ b/kern/vm/addrspace.c
@@ -32,13 +32,40 @@
 #include <lib.h>
 #include <addrspace.h>
 #include <vm.h>
-
+#include <spl.h>
+#include <mips/tlb.h>
 /*
  * Note! If OPT_DUMBVM is set, as is the case until you start the VM
  * assignment, this file is not compiled or linked or in any way
  * used. The cheesy hack versions in dumbvm.c are used instead.
  */
 
+
+#define DUMBVM_STACKPAGES    12
+
+
+
+/*struct addrspace *
+as_create(void)
+{
+        struct addrspace *as = kmalloc(sizeof(struct addrspace));
+        if (as==NULL) {
+                return NULL;
+        }
+
+        as->as_vbase1 = 0;
+        as->as_pbase1 = 0;
+        as->as_npages1 = 0;
+        as->as_vbase2 = 0;
+        as->as_pbase2 = 0;
+        as->as_npages2 = 0;
+        as->as_stackpbase = 0;
+
+        return as;
+}
+*/
+
+
 struct addrspace *
 as_create(void)
 {
@@ -53,9 +80,80 @@ as_create(void)
 	 * Initialize as needed.
 	 */
 
+//	as->page_table = kmalloc(sizeof(struct page));
+//	as->stack = NULL;
+//	as->heap = NULL;
+
+//	set the code region
+	as->code_vbase = (vaddr_t)0;
+	as->code_page_number = 0;
+	as->page_table = NULL;
+
+	//static region set up
+	as->static_vbase = (vaddr_t)0;
+	as->static_page_number = 0;
+	as->static_region_start = NULL;
+
+//	set the heap region
+	as->heap_start = (vaddr_t)0;
+	as->heap_end = (vaddr_t)0;
+//	as->dynamic_end = (paddr_t)0;
+	as->heap_region_start = NULL;
+
+
+//	set the stack region
+	as->stack_bottom = (vaddr_t)0;
+	as->stack_region_start = NULL;
+//	as->stack_end = (vaddr_t)0;
+//	as->stack_paddress = (paddr_t)0;
+
+
 	return as;
 }
 
+/*
+int
+as_copy(struct addrspace *old, struct addrspace **ret)
+{
+        struct addrspace *new;
+
+        new = as_create();
+        if (new==NULL) {
+                return ENOMEM;
+        }
+
+        new->as_vbase1 = old->as_vbase1;
+        new->as_npages1 = old->as_npages1;
+        new->as_vbase2 = old->as_vbase2;
+        new->as_npages2 = old->as_npages2;
+*/
+        /* (Mis)use as_prepare_load to allocate some physical memory. */
+/*      if (as_prepare_load(new)) {
+                as_destroy(new);
+                return ENOMEM;
+        }
+
+        KASSERT(new->as_pbase1 != 0);
+        KASSERT(new->as_pbase2 != 0);
+        KASSERT(new->as_stackpbase != 0);
+
+        memmove((void *)PADDR_TO_KVADDR(new->as_pbase1),
+                (const void *)PADDR_TO_KVADDR(old->as_pbase1),
+                old->as_npages1*PAGE_SIZE);
+
+        memmove((void *)PADDR_TO_KVADDR(new->as_pbase2),
+                (const void *)PADDR_TO_KVADDR(old->as_pbase2),
+                old->as_npages2*PAGE_SIZE);
+
+        memmove((void *)PADDR_TO_KVADDR(new->as_stackpbase),
+                (const void *)PADDR_TO_KVADDR(old->as_stackpbase),
+                DUMBVM_STACKPAGES*PAGE_SIZE);
+        
+        *ret = new;
+        return 0;
+                     
+}*/
+
 int
 as_copy(struct addrspace *old, struct addrspace **ret)
 {
@@ -65,27 +163,256 @@ as_copy(struct addrspace *old, struct addrspace **ret)
 	if (newas==NULL) {
 		return ENOMEM;
 	}
-
 	/*
 	 * Write this.
 	 */
 
+	struct page *pagepointer = old->page_table;
+	struct page *newpages;
+
+	bool firstpage = true;
+
+	if(old->page_table != NULL){
+		while(pagepointer != NULL){
+			if(firstpage){
+				newas->page_table = (struct page*)kmalloc(sizeof(struct page));
+				firstpage = false;
+				newpages = newas->page_table;
+			}
+			else{
+				newpages->next = (struct page*)kmalloc(sizeof(struct page));
+				newpages = newpages->next;
+			}
+			newpages->virtualAddress = pagepointer->virtualAddress;
+			newpages->write_flag = pagepointer->write_flag;
+			newpages->read_flag = pagepointer->read_flag;
+			newpages->exec_flag = pagepointer->exec_flag;
+			newpages->physicalAddress = page_alloc(1);
+			if(newpages->physicalAddress == 0){
+				as_destroy(newas);
+				return ENOMEM;
+			}
+			memmove((void *)PADDR_TO_KVADDR(newpages->physicalAddress), (const void *)PADDR_TO_KVADDR(pagepointer->physicalAddress), PAGE_SIZE);
+//			memmove((void *)PADDR_TO_KVADDR(new->as_stackpbase), (const void *)PADDR_TO_KVADDR(old->as_stackpbase),DUMBVM_STACKPAGES*PAGE_SIZE);
+			newpages->next = NULL;
+//			if(firstpage){
+//				newas->page_table = newpages;
+//				firstpage = false;
+//			}
+//			newpages = newpages->next;
+			pagepointer = pagepointer->next;
+		}
+		
+//		newas->page_table = temppage;
+		newas->code_vbase = old->page_table->virtualAddress;
+		newas->code_page_number = old->code_page_number;
+	}
+
+
+	if(old->static_region_start != NULL){
+		pagepointer = old->static_region_start;
+		firstpage = true;
+               	while(pagepointer != NULL){
+			if(firstpage){
+                                newas->static_region_start = (struct page*)kmalloc(sizeof(struct page));
+                                firstpage = false;
+                                newpages = newas->static_region_start;
+                        }
+                        else{
+                                newpages->next = (struct page*)kmalloc(sizeof(struct page));
+                                newpages = newpages->next;
+                        }
+
+//                       	newpages = (struct page*)kmalloc(sizeof(struct page));
+                       	newpages->virtualAddress = pagepointer->virtualAddress;
+                       	newpages->write_flag = pagepointer->write_flag;
+                       	newpages->read_flag = pagepointer->read_flag;
+                       	newpages->exec_flag = pagepointer->exec_flag;
+                       	newpages->physicalAddress = page_alloc(1);
+                       	if(newpages->physicalAddress == 0){        
+                        	as_destroy(newas);
+                                return ENOMEM;
+                        }
+			memmove((void *)PADDR_TO_KVADDR(newpages->physicalAddress), (const void *)PADDR_TO_KVADDR(pagepointer->physicalAddress), PAGE_SIZE);
+
+                       	newpages->next = NULL;
+//                       	if(firstpage){
+//                               	newas->static_region_start = newpages;
+//                               	firstpage = false;
+//                       	}
+//                       	newpages = newpages->next;
+			pagepointer = pagepointer->next;
+               	}
+//             	newas->page_table = temppage;
+               	newas->static_vbase = old->static_region_start->virtualAddress;
+               	newas->static_page_number = old->static_page_number;
+       	}
+		
+
+	if(old->heap_region_start != NULL){
+                pagepointer = old->heap_region_start;
+                firstpage = true;
+                while(pagepointer != NULL){
+  
+			if(firstpage){
+                                newas->heap_region_start = (struct page*)kmalloc(sizeof(struct page));
+                                firstpage = false;
+                                newpages = newas->heap_region_start;
+                        }
+                        else{
+                                newpages->next = (struct page*)kmalloc(sizeof(struct page));
+                                newpages = newpages->next;
+                        }
+
+//                      newpages = (struct page*)kmalloc(sizeof(struct page));
+                        newpages->virtualAddress = pagepointer->virtualAddress;
+                        newpages->write_flag = pagepointer->write_flag;
+                        newpages->read_flag = pagepointer->read_flag;
+                        newpages->exec_flag = pagepointer->exec_flag;
+                        newpages->physicalAddress = page_alloc(1);
+                        if(newpages->physicalAddress == 0){
+                                as_destroy(newas);
+                                return ENOMEM;
+                        }
+			memmove((void *)PADDR_TO_KVADDR(newpages->physicalAddress), (const void *)PADDR_TO_KVADDR(pagepointer->physicalAddress), PAGE_SIZE);
+
+                        newpages->next = NULL;
+//                        if(firstpage){
+//                                newas->heap_region_start = newpages;
+//                                firstpage = false;
+//                        }
+//                        newpages = newpages->next;
+			pagepointer = pagepointer->next;
+                }
+//              newas->page_table = temppage;
+                newas->heap_start = old->heap_start;
+                newas->heap_end = old->heap_end;
+        }
+
+	if(old->stack_region_start != NULL){
+                pagepointer = old->stack_region_start;
+                firstpage = true;
+                while(pagepointer != NULL){
+			if(firstpage){
+                                newas->stack_region_start = (struct page*)kmalloc(sizeof(struct page));
+                                firstpage = false;
+                                newpages = newas->stack_region_start;
+                        }
+                        else{
+                                newpages->next = (struct page*)kmalloc(sizeof(struct page));
+                                newpages = newpages->next;
+                        }
+
+//                        newpages = (struct page*)kmalloc(sizeof(struct page));
+                        newpages->virtualAddress = pagepointer->virtualAddress;
+                        newpages->write_flag = pagepointer->write_flag;
+                        newpages->read_flag = pagepointer->read_flag;
+                        newpages->exec_flag = pagepointer->exec_flag;
+                        newpages->physicalAddress = page_alloc(1);
+                        if(newpages->physicalAddress == 0){
+                                as_destroy(newas);
+                                return ENOMEM;
+                        }
+			memmove((void *)PADDR_TO_KVADDR(newpages->physicalAddress), (const void *)PADDR_TO_KVADDR(pagepointer->physicalAddress), PAGE_SIZE);
+
+                        newpages->next = NULL;
+//                        if(firstpage){
+//                                newas->stack_region_start = newpages;
+//                                firstpage = false;
+//                        }
+//                        newpages = newpages->next;
+			pagepointer = pagepointer->next;
+                }
+//              newas->page_table = temppage;
+                newas->stack_bottom = old->stack_bottom;
+        }
+
+
 	(void)old;
 	
 	*ret = newas;
 	return 0;
 }
 
+/*
+void
+as_destroy(struct addrspace *as)
+{
+        kfree(as);
+}
+*/
+
 void
 as_destroy(struct addrspace *as)
 {
 	/*
 	 * Clean up as needed.
 	 */
-	
+	if(as != NULL){
+		struct page* temp1 = as->page_table;
+		struct page* temp2;
+
+		//free the code region
+		while((temp1 != NULL)&&(temp1 != (struct page *)0xdeadbeef)){
+			temp2 = temp1;
+			temp1 = temp2->next;
+			freeoneaddress(temp2->physicalAddress);
+			kfree(temp2);
+		}
+
+		//free the static region
+		temp1 = as->static_region_start;
+		while((temp1 != NULL)&&(temp1 != (struct page *)0xdeadbeef)){
+			 temp2 = temp1;
+                        temp1 = temp2->next;
+                        freeoneaddress(temp2->physicalAddress);
+                        kfree(temp2);
+		}
+
+		//free the heap region
+		temp1 = as->heap_region_start;
+                while((temp1 != NULL)&&(temp1 != (struct page *)0xdeadbeef)){
+                         temp2 = temp1;
+                        temp1 = temp2->next;
+                        freeoneaddress(temp2->physicalAddress);
+                        kfree(temp2);
+                }
+
+		//free the stack region. This code duplication pains me.
+		temp1 = as->stack_region_start;
+                while((temp1 != NULL)&&(temp1 != (struct page *)0xdeadbeef)){
+                         temp2 = temp1;
+                        temp1 = temp2->next;
+                        freeoneaddress(temp2->physicalAddress);
+                        kfree(temp2);
+                }
+
+
+		
+	}	
+
 	kfree(as);
 }
 
+/*void
+as_activate(struct addrspace *as)
+{
+        int i, spl;
+
+        (void)as;
+*/
+        /* Disable interrupts on this CPU while frobbing the TLB. */
+/*      spl = splhigh();
+
+        for (i=0; i<NUM_TLB; i++) {
+                tlb_write(TLBHI_INVALID(i), TLBLO_INVALID(), i);
+        }
+
+        splx(spl);
+}
+*/
+
+
 void
 as_activate(struct addrspace *as)
 {
@@ -93,10 +420,63 @@ as_activate(struct addrspace *as)
 	 * Write this.
 	 */
 
-	(void)as;  // suppress warning until code gets written
+        int i, spl;
+
+        (void)as;
+
+        /* Disable interrupts on this CPU while frobbing the TLB. */
+        spl = splhigh();
+
+        for (i=0; i<NUM_TLB; i++) {
+                tlb_write(TLBHI_INVALID(i), TLBLO_INVALID(), i);
+        }
+
+        splx(spl);
+
+
 }
 
 /*
+int
+as_define_region(struct addrspace *as, vaddr_t vaddr, size_t sz,
+                 int readable, int writeable, int executable)
+{
+        size_t npages; 
+*/
+        /* Align the region. First, the base... */
+/*      sz += vaddr & ~(vaddr_t)PAGE_FRAME;
+        vaddr &= PAGE_FRAME;
+
+*/      /* ...and now the length. */
+/*      sz = (sz + PAGE_SIZE - 1) & PAGE_FRAME;
+
+        npages = sz / PAGE_SIZE;
+*/
+        /* We don't use these - all pages are read-write */
+/*      (void)readable;
+        (void)writeable;
+        (void)executable;
+
+        if (as->as_vbase1 == 0) {
+                as->as_vbase1 = vaddr;
+                as->as_npages1 = npages;
+                return 0;
+        }
+
+        if (as->as_vbase2 == 0) {
+                as->as_vbase2 = vaddr;
+                as->as_npages2 = npages;
+                return 0;
+        }
+*/
+        /*
+         * Support for more than two regions is not available.
+         */
+/*      kprintf("dumbvm: Warning: too many regions\n");
+        return EUNIMP;
+}
+*/
+/*
  * Set up a segment at virtual address VADDR of size MEMSIZE. The
  * segment in memory extends from VADDR up to (but not including)
  * VADDR+MEMSIZE.
@@ -106,6 +486,7 @@ as_activate(struct addrspace *as)
  * moment, these are ignored. When you write the VM system, you may
  * want to implement them.
  */
+
 int
 as_define_region(struct addrspace *as, vaddr_t vaddr, size_t sz,
 		 int readable, int writeable, int executable)
@@ -114,14 +495,104 @@ as_define_region(struct addrspace *as, vaddr_t vaddr, size_t sz,
 	 * Write this.
 	 */
 
-	(void)as;
+	size_t npages; 
+
+        /* Align the region. First, the base... */
+        sz += vaddr & ~(vaddr_t)PAGE_FRAME;
+        vaddr &= PAGE_FRAME;
+
+        /* ...and now the length. */
+        sz = (sz + PAGE_SIZE - 1) & PAGE_FRAME;
+
+        npages = sz / PAGE_SIZE;
+
+
+	//the first call will set up the code region
+	if(as->code_vbase == 0){	
+		as->code_page_number = npages;
+		as->code_vbase = vaddr;
+		as->page_table = (struct page *)kmalloc(sizeof(struct page));
+		as->page_table->next = NULL;
+		as->page_table->write_flag = writeable;
+		as->page_table->read_flag = readable;
+		as->page_table->exec_flag = executable;
+		as->page_table->virtualAddress = vaddr;
+		as->page_table->physicalAddress = 0;
+		return 0;
+	}
+
+
+	//the second call will set up the static region and the heap bacause why not?
+	if(as->static_vbase == 0){
+		as->static_vbase = vaddr;
+		as->static_page_number = npages;
+		as->static_region_start = (struct page*)kmalloc(sizeof(struct page));
+		as->static_region_start->next = NULL;
+		as->static_region_start->write_flag = writeable;
+		as->static_region_start->read_flag = readable;
+		as->static_region_start->exec_flag = executable;
+		as->static_region_start->virtualAddress = vaddr;
+		as->static_region_start->physicalAddress = 0;	
+
+		//I'll move this down to as_prepare_load since it looks nicer down there
+/*		as->heap_start = vaddr + sz;
+		as->heap_region_start = (struct page *)kmalloc(sizeof(struct page));
+		as->heap_region_start->next = NULL;
+		as->heap_region_start->virtualAddress = as->heap_start;
+		as->heap_region_start->physicalAddress = 0;
+		as->heap_region_start->write_flag = 1;
+		as->heap_region_start->read_flag = 1;
+		as->heap_region_start->exec_flag = 0;		
+*/
+		return 0;
+	}
+	kprintf("dumbvm: Warning: too many regions\n");
+        return EUNIMP;
+
+
+/*	(void)as;
 	(void)vaddr;
 	(void)sz;
 	(void)readable;
 	(void)writeable;
 	(void)executable;
 	return EUNIMP;
+*/
+
+}
+
+
+
+/*
+int
+as_prepare_load(struct addrspace *as)
+{
+        KASSERT(as->as_pbase1 == 0);
+        KASSERT(as->as_pbase2 == 0);
+        KASSERT(as->as_stackpbase == 0);
+
+        as->as_pbase1 = getppages(as->as_npages1);
+        if (as->as_pbase1 == 0) {
+                return ENOMEM;
+        }
+
+        as->as_pbase2 = getppages(as->as_npages2);
+        if (as->as_pbase2 == 0) {
+                return ENOMEM;
+        }
+
+        as->as_stackpbase = getppages(DUMBVM_STACKPAGES);
+        if (as->as_stackpbase == 0) {
+                return ENOMEM;
+        }
+        
+        as_zero_region(as->as_pbase2, as->as_npages2);
+        as_zero_region(as->as_stackpbase, DUMBVM_STACKPAGES);
+
+        return 0;
 }
+*/
+
 
 int
 as_prepare_load(struct addrspace *as)
@@ -129,22 +600,149 @@ as_prepare_load(struct addrspace *as)
 	/*
 	 * Write this.
 	 */
+	
+	size_t i;
+	vaddr_t vaddr = as->page_table->virtualAddress;
+	struct page* page_pointer = as->page_table;
+
+
+	//loops through the code page table and sets up the region with the flags and addresses
+	for(i = 0; i < as->code_page_number; i++){
+		if(i == 0){
+			page_pointer->physicalAddress = page_alloc(1); 
+			if(page_pointer->physicalAddress == 0){
+				return ENOMEM;
+			}
+		}
+		else{
+			page_pointer->next = (struct page*)kmalloc(sizeof(struct page));
+			page_pointer = page_pointer->next;
+			page_pointer->virtualAddress = vaddr;
+			page_pointer->write_flag = as->page_table->write_flag;
+			page_pointer->read_flag = as->page_table->read_flag;
+			page_pointer->exec_flag = as->page_table->exec_flag;
+			page_pointer->physicalAddress = page_alloc(1);
+			if(page_pointer->physicalAddress == 0){
+				return ENOMEM;
+			}		
+			page_pointer->next = NULL;
+		}
+		vaddr = vaddr + PAGE_SIZE;
+	}
+
+	//now do the same with the static region. code duplication sucks, but I'll leave it for now
+	page_pointer = as->static_region_start;
+	vaddr = as->static_region_start->virtualAddress;
+
+	for(i = 0; i < as->static_page_number; i++){
+                if(i == 0){
+                        page_pointer->physicalAddress = page_alloc(1);
+                        if(page_pointer->physicalAddress == 0){
+                                return ENOMEM;
+                        }
+                }
+                else{
+                        page_pointer->next = (struct page*)kmalloc(sizeof(struct page));
+			page_pointer = page_pointer->next; 
+                        page_pointer->virtualAddress = vaddr;
+                        page_pointer->write_flag = as->page_table->write_flag;
+                        page_pointer->read_flag = as->page_table->read_flag;
+                        page_pointer->exec_flag = as->page_table->exec_flag;
+                        page_pointer->physicalAddress = page_alloc(1);
+                        if(page_pointer->physicalAddress == 0){
+                                return ENOMEM;
+                        }
+                        page_pointer->next = NULL;
+                }
+                vaddr = vaddr + PAGE_SIZE;
+        }
+
+
+	//I'll just set up the heap real quick since I have the vaddr already, there isn't much anyway
+//	page_pointer = as->heap_region_start;
+	as->heap_region_start = (struct page*)kmalloc(sizeof(struct page));
+	as->heap_region_start->virtualAddress = vaddr;
+	as->heap_region_start->physicalAddress = page_alloc(1);
+	if(as->heap_region_start->physicalAddress == 0){
+		return ENOMEM;
+	}
+	as->heap_region_start->write_flag = 1;
+	as->heap_region_start->read_flag = 1;
+	as->heap_region_start->exec_flag = 0;
+	as->heap_region_start->next = NULL;
+
+	//heap start and heap end
+	as->heap_start = vaddr;
+	as->heap_end = vaddr;
+
+
+
+	//now for the stack......yay...., I joke, but it's probably going to be similar to the code and static regions I'll just use the same number of stack pages as DUMBVM
+	vaddr = USERSTACK - (DUMBVM_STACKPAGES * PAGE_SIZE);
+//	page_pointer = as->stack_region_start;
+	for(i = 0; i < DUMBVM_STACKPAGES; i++){
+		
+		if(i == 0){
+			as->stack_region_start = (struct page *)kmalloc(sizeof(struct page));
+			page_pointer = as->stack_region_start;
+
+		}
+		else {
+			page_pointer->next = (struct page *)kmalloc(sizeof(struct page));
+			page_pointer = page_pointer->next;
+		}
+
+		page_pointer->virtualAddress = vaddr;
+		page_pointer->physicalAddress = page_alloc(1);
+		if(page_pointer->physicalAddress == 0){
+			return ENOMEM;
+		}
+		page_pointer->next =  NULL;
+		page_pointer->write_flag = 1;
+		page_pointer->read_flag = 1;
+		page_pointer->exec_flag = 0;
+		
+		vaddr = vaddr + PAGE_SIZE;
+//		page_pointer = page_pointer->next;
+	}
+	as->stack_bottom = as->stack_region_start->virtualAddress;
 
-	(void)as;
 	return 0;
 }
 
+/*
+int
+as_complete_load(struct addrspace *as)
+{
+        (void)as;
+        return 0;
+}
+
+*/
+
 int
 as_complete_load(struct addrspace *as)
 {
 	/*
 	 * Write this.
 	 */
+//	do I really need to do anythig here? the blog says to change the flags back, but I have doubts about that. We'll see I guess
 
 	(void)as;
 	return 0;
 }
 
+/*
+int
+as_define_stack(struct addrspace *as, vaddr_t *stackptr)
+{
+        KASSERT(as->as_stackpbase != 0);
+
+        *stackptr = USERSTACK;
+        return 0;
+}
+*/
+
 int
 as_define_stack(struct addrspace *as, vaddr_t *stackptr)
 {
@@ -156,7 +754,7 @@ as_define_stack(struct addrspace *as, vaddr_t *stackptr)
 
 	/* Initial user-level stack pointer */
 	*stackptr = USERSTACK;
-	
+//	stackptr should be the top of the stack, so I guess I don't have to do anything here either	
 	return 0;
 }
 
diff --git a/kern/vm/vm.c b/kern/vm/vm.c
new file mode 100644
index 0000000..7b3abd6
--- /dev/null
+++ b/kern/vm/vm.c
@@ -0,0 +1,629 @@
+/*
+ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+ *	The President and Fellows of Harvard College.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <types.h>
+#include <kern/errno.h>
+#include <lib.h>
+#include <spl.h>
+#include <spinlock.h>
+#include <thread.h>
+#include <current.h>
+#include <mips/tlb.h>
+#include <addrspace.h>
+#include <vm.h>
+
+/*
+ * Dumb MIPS-only "VM system" that is intended to only be just barely
+ * enough to struggle off the ground. You should replace all of this
+ * code while doing the VM assignment. In fact, starting in that
+ * assignment, this file is not included in your kernel!
+ */
+
+/* under dumbvm, always have 48k of user stack */
+#define DUMBVM_STACKPAGES    12
+
+/*
+ * Wrap rma_stealmem in a spinlock.
+ */
+static struct spinlock stealmem_lock = SPINLOCK_INITIALIZER;
+
+struct coremap_page* coremap;
+int total_page_num;
+paddr_t firstaddr, lastaddr, freeaddr;
+bool booted = false;
+int TLBindex = 0;
+
+void
+vm_bootstrap(void)
+{
+//	paddr_t firstaddr, lastaddr;
+	ram_getsize(&firstaddr, &lastaddr);
+//	total_page_num = ROUNDDOWN(lastaddr, PAGE_SIZE) / PAGE_SIZE;
+	total_page_num = (lastaddr - firstaddr) / PAGE_SIZE;
+	coremap = (struct coremap_page*)PADDR_TO_KVADDR(firstaddr);
+	freeaddr = firstaddr + total_page_num * sizeof(struct coremap_page);
+
+	//I need to make this ROUNDDOWN or something
+	//int fixedPageMaxIndex = (freeaddr - firstaddr) / PAGE_SIZE;
+
+	//ROUNDUP
+
+	for(int i = 0; i < total_page_num; i++){
+
+		coremap[i].virtualAddress = PADDR_TO_KVADDR(PAGE_SIZE * i + firstaddr);
+		coremap[i].physicalAddress = PAGE_SIZE * i + firstaddr;
+		if(coremap[i].physicalAddress < freeaddr){//i < fixedPageMaxIndex){
+			coremap[i].state = FIXED;//0;//"fixed"; strings didn't work, so I'll use 0
+		}
+		else{
+			coremap[i].state = FREE;//1;//"free"; I guess I'll make free = 1
+		}
+	}
+	//flag for vm booted? will it be a number or something? a bool?
+	booted = true;
+	int temp = free_core_page_number();
+	kprintf("%d", temp);
+}
+
+int free_core_page_number(){
+	spinlock_acquire(&stealmem_lock);
+	int freecount = 0;
+	for(int i = 0; i < total_page_num; i++){
+		if(coremap[i].state == FREE){
+			freecount++;
+		}
+	}
+	spinlock_release(&stealmem_lock);
+	return freecount;
+}
+
+static
+paddr_t
+getppages(unsigned long npages)
+{
+	paddr_t addr;
+
+	spinlock_acquire(&stealmem_lock);
+
+	addr = ram_stealmem(npages);
+	
+	spinlock_release(&stealmem_lock);
+	return addr;
+}
+
+paddr_t page_alloc(int npages){
+	int index = 0;
+        if(booted){
+
+//		int temp = free_core_page_number();
+//        kprintf("\n page_alloc %d\n", temp);
+
+                spinlock_acquire(&stealmem_lock);
+                int contig_free_pages = 0;
+                int start_free_pages = 0;
+                bool in_free_block = false;
+                bool found_entire_block = false;
+
+
+                for(index = 0; index < total_page_num; index++){
+                        if(coremap[index].state == FREE){
+                                contig_free_pages++;
+                                if(in_free_block == false){
+                                        start_free_pages = index;
+                                        in_free_block = true;
+                                }
+                                if(contig_free_pages == npages){
+                                        found_entire_block = true;
+                                        break;
+                                }
+                        }
+                        else{
+                                in_free_block = false;
+                                contig_free_pages = 0;
+                        }
+                }
+		
+
+		
+                if(found_entire_block == false){
+			kprintf("tough luck, no core map page left\n");
+                        spinlock_release(&stealmem_lock);
+                        return 0;
+                }
+                for(index = 0; index < npages; index++){
+                        coremap[index + start_free_pages].state = DIRTY;
+                        coremap[index + start_free_pages].first_block_index = start_free_pages;
+                }
+                spinlock_release(&stealmem_lock);
+                return coremap[start_free_pages].physicalAddress;
+        }
+	else{
+//              spinlock_acquire(&stealmem_lock);
+                paddr_t pa;
+                pa = getppages(npages);
+                if (pa==0) {
+                        return 0;
+                }
+//              spinlock_release(&stealmem_lock);
+                return pa;
+        }
+
+}
+
+/* Allocate/free some kernel-space virtual pages */
+vaddr_t 
+alloc_kpages(int npages)
+{
+	int index = 0;
+	if(booted){
+
+//		int temp = free_core_page_number();
+//        kprintf("\n alloc_kpages %d\n", temp);
+
+		spinlock_acquire(&stealmem_lock);
+		int contig_free_pages = 0;
+		int start_free_pages = 0;
+		bool in_free_block = false;
+		bool found_entire_block = false;
+
+
+		for(index = 0; index < total_page_num; index++){
+			if(coremap[index].state == FREE){
+				contig_free_pages++;
+				if(in_free_block == false){
+					start_free_pages = index;
+					in_free_block = true;
+				}
+				if(contig_free_pages == npages){
+					found_entire_block = true;
+					break;
+				}
+			}
+			else{
+				in_free_block = false;
+				contig_free_pages = 0;
+			}
+		}
+		if(found_entire_block == false){
+			kprintf("sucks to be you, not enough coremap pages\n");
+			spinlock_release(&stealmem_lock);
+			return 0;
+		}
+		for(index = 0; index < npages; index++){
+			coremap[index + start_free_pages].state = DIRTY;
+			coremap[index + start_free_pages].first_block_index = start_free_pages;
+		}
+		spinlock_release(&stealmem_lock);
+		return PADDR_TO_KVADDR(coremap[start_free_pages].physicalAddress);
+	}
+	else{
+//		spinlock_acquire(&stealmem_lock);
+		paddr_t pa;
+		pa = getppages(npages);
+		if (pa==0) {
+			return 0;
+		}
+//		spinlock_release(&stealmem_lock);
+		return PADDR_TO_KVADDR(pa);
+	}
+}
+
+void 
+free_kpages(vaddr_t addr)
+{
+	/* nothing - leak the memory. */
+
+//	(void)addr;
+	int index;
+	int addr_start_index;
+	spinlock_acquire(&stealmem_lock);
+
+	for(index = 0; index < total_page_num; index++){
+		if(coremap[index].virtualAddress == addr){
+		
+			addr_start_index = coremap[index].first_block_index;
+
+			while(coremap[index].first_block_index == addr_start_index){
+				coremap[index].state = FREE;
+				index++;
+			}
+
+			break;
+		}
+	}
+
+	spinlock_release(&stealmem_lock);
+	
+}
+
+//helper function for as_destroy
+void freeoneaddress(paddr_t pa){
+	spinlock_acquire(&stealmem_lock);
+	for (int i = 0; i<total_page_num; i++){
+        	if(coremap[i].physicalAddress == pa){
+                	coremap[i].state = FREE;
+                        break;
+                }
+        }
+	spinlock_release(&stealmem_lock);
+}
+
+void
+vm_tlbshootdown_all(void)
+{
+	panic("dumbvm tried to do tlb shootdown?!\n");
+}
+
+void
+vm_tlbshootdown(const struct tlbshootdown *ts)
+{
+	(void)ts;
+	panic("dumbvm tried to do tlb shootdown?!\n");
+}
+
+int
+vm_fault(int faulttype, vaddr_t faultaddress)
+{
+	vaddr_t stackbase, stacktop;//vbase1, vtop1, vbase2, vtop2, stackbase, stacktop;
+	paddr_t paddr;
+	int i;
+	uint32_t ehi, elo;
+	struct addrspace *as;
+	int spl;
+//	struct page* entry;
+
+	faultaddress &= PAGE_FRAME;
+
+	DEBUG(DB_VM, "dumbvm: fault: 0x%x\n", faultaddress);
+
+	switch (faulttype) {
+	    case VM_FAULT_READONLY:
+		/* We always create pages read-write, so we can't get this */
+		panic("dumbvm: got VM_FAULT_READONLY\n");
+	    case VM_FAULT_READ:
+	    case VM_FAULT_WRITE:
+		break;
+	    default:
+		return EINVAL;
+	}
+
+	as = curthread->t_addrspace;
+	if (as == NULL) {
+		/*
+		 * No address space set up. This is probably a kernel
+		 * fault early in boot. Return EFAULT so as to panic
+		 * instead of getting into an infinite faulting loop.
+		 */
+		return EFAULT;
+	}
+
+	/* Assert that the address space has been set up properly. */
+/*	KASSERT(as->as_vbase1 != 0);
+	KASSERT(as->as_pbase1 != 0);
+	KASSERT(as->as_npages1 != 0);
+	KASSERT(as->as_vbase2 != 0);
+	KASSERT(as->as_pbase2 != 0);
+	KASSERT(as->as_npages2 != 0);
+	KASSERT(as->as_stackpbase != 0);
+	KASSERT((as->as_vbase1 & PAGE_FRAME) == as->as_vbase1);
+	KASSERT((as->as_pbase1 & PAGE_FRAME) == as->as_pbase1);
+	KASSERT((as->as_vbase2 & PAGE_FRAME) == as->as_vbase2);
+	KASSERT((as->as_pbase2 & PAGE_FRAME) == as->as_pbase2);
+	KASSERT((as->as_stackpbase & PAGE_FRAME) == as->as_stackpbase);
+
+	vbase1 = as->as_vbase1;
+	vtop1 = vbase1 + as->as_npages1 * PAGE_SIZE;
+	vbase2 = as->as_vbase2;
+	vtop2 = vbase2 + as->as_npages2 * PAGE_SIZE;
+	stackbase = USERSTACK - DUMBVM_STACKPAGES * PAGE_SIZE;
+	stacktop = USERSTACK;
+*/
+	KASSERT(as->page_table != NULL);
+	KASSERT(as->static_region_start != NULL);
+	KASSERT(as->heap_region_start != NULL);
+	KASSERT(as->stack_region_start != NULL);
+
+	KASSERT((as->code_vbase & PAGE_FRAME) == (as->code_vbase));
+	KASSERT(as->code_page_number != 0);
+	
+	KASSERT((as->static_vbase & PAGE_FRAME) == (as->static_vbase));
+	KASSERT(as->static_page_number != 0);
+
+	
+
+	stackbase = USERSTACK - DUMBVM_STACKPAGES * PAGE_SIZE;
+        stacktop = USERSTACK;
+
+
+
+/*	if (faultaddress >= vbase1 && faultaddress < vtop1) {
+		paddr = (faultaddress - vbase1) + as->as_pbase1;
+	}
+	else if (faultaddress >= vbase2 && faultaddress < vtop2) {
+		paddr = (faultaddress - vbase2) + as->as_pbase2;
+	}
+	else if (faultaddress >= stackbase && faultaddress < stacktop) {
+		paddr = (faultaddress - stackbase) + as->as_stackpbase;
+	}
+	else {
+		return EFAULT;
+	}
+*/
+
+
+	//check the stack for the fault address first since that is easier to check for in an if statement
+
+	//start going through the page table to find the fault address
+	struct page *pagepointer;
+	paddr = (paddr_t)0;
+
+		
+
+	if((faultaddress >= as->stack_bottom) && (faultaddress < USERSTACK)){
+		pagepointer = as->stack_region_start;
+	}
+	else if(faultaddress >= as->heap_start){
+		pagepointer = as->heap_region_start;
+	}
+	else if(faultaddress >= as->static_vbase){
+		pagepointer = as->static_region_start;
+	}
+	else if(faultaddress >= as->code_vbase){
+		pagepointer = as->page_table;
+	}
+	else{
+	//it's not in any of the regions so return EFAULT or something
+		return EFAULT;
+	}
+
+	while(pagepointer != NULL){
+                if((faultaddress >= pagepointer->virtualAddress) && (faultaddress < (pagepointer->virtualAddress + PAGE_SIZE))){
+                        //paddr = (faultaddress - stackbase) + as->as_stackpbase;
+                        paddr = (faultaddress - pagepointer->virtualAddress) + pagepointer->physicalAddress;
+                        break;
+                }
+                pagepointer = pagepointer->next;
+        }
+
+	if(paddr == 0){
+		return EFAULT;
+	}
+
+
+	/* make sure it's page-aligned */
+	KASSERT((paddr & PAGE_FRAME) == paddr);
+
+	/* Disable interrupts on this CPU while frobbing the TLB. */
+	spl = splhigh();
+
+//	kprintf("%d", TLBindex);	
+	for (i=0; i<NUM_TLB; i++) {
+		tlb_read(&ehi, &elo, i);
+		if (elo & TLBLO_VALID) {
+			continue;
+		}
+//		kprintf("%p and %p\n",  (void *)paddr, (void *)faultaddress);
+		ehi = faultaddress;
+		elo = paddr | TLBLO_DIRTY | TLBLO_VALID;
+		DEBUG(DB_VM, "dumbvm: 0x%x -> 0x%x\n", faultaddress, paddr);
+		tlb_write(ehi, elo, i);
+		splx(spl);
+		return 0;
+	}
+//	kprintf("M14");	
+//	i = rand() % 63;
+	ehi = faultaddress;
+	elo = paddr | TLBLO_DIRTY | TLBLO_VALID;
+	tlb_write(ehi, elo, TLBindex);
+	splx(spl);
+	TLBindex++;
+	if(TLBindex == 63){
+		TLBindex = 0;
+	}
+	return 0;
+
+/*	kprintf("dumbvm: Ran out of TLB entries - cannot handle page fault\n");
+	splx(spl);
+	return EFAULT;
+*/
+}
+
+/*struct addrspace *
+as_create(void)
+{
+	struct addrspace *as = kmalloc(sizeof(struct addrspace));
+	if (as==NULL) {
+		return NULL;
+	}
+
+	as->as_vbase1 = 0;
+	as->as_pbase1 = 0;
+	as->as_npages1 = 0;
+	as->as_vbase2 = 0;
+	as->as_pbase2 = 0;
+	as->as_npages2 = 0;
+	as->as_stackpbase = 0;
+
+	return as;
+}
+
+void
+as_destroy(struct addrspace *as)
+{
+	kfree(as);
+}
+*/
+
+/*void
+as_activate(struct addrspace *as)
+{
+	int i, spl;
+
+	(void)as;
+*/
+	/* Disable interrupts on this CPU while frobbing the TLB. */
+/*	spl = splhigh();
+
+	for (i=0; i<NUM_TLB; i++) {
+		tlb_write(TLBHI_INVALID(i), TLBLO_INVALID(), i);
+	}
+
+	splx(spl);
+}
+
+int
+as_define_region(struct addrspace *as, vaddr_t vaddr, size_t sz,
+		 int readable, int writeable, int executable)
+{
+	size_t npages; 
+*/
+	/* Align the region. First, the base... */
+/*	sz += vaddr & ~(vaddr_t)PAGE_FRAME;
+	vaddr &= PAGE_FRAME;
+
+*/	/* ...and now the length. */
+/*	sz = (sz + PAGE_SIZE - 1) & PAGE_FRAME;
+
+	npages = sz / PAGE_SIZE;
+*/
+	/* We don't use these - all pages are read-write */
+/*	(void)readable;
+	(void)writeable;
+	(void)executable;
+
+	if (as->as_vbase1 == 0) {
+		as->as_vbase1 = vaddr;
+		as->as_npages1 = npages;
+		return 0;
+	}
+
+	if (as->as_vbase2 == 0) {
+		as->as_vbase2 = vaddr;
+		as->as_npages2 = npages;
+		return 0;
+	}
+*/
+	/*
+	 * Support for more than two regions is not available.
+	 */
+/*	kprintf("dumbvm: Warning: too many regions\n");
+	return EUNIMP;
+}
+
+static
+void
+as_zero_region(paddr_t paddr, unsigned npages)
+{
+	bzero((void *)PADDR_TO_KVADDR(paddr), npages * PAGE_SIZE);
+}
+
+int
+as_prepare_load(struct addrspace *as)
+{
+	KASSERT(as->as_pbase1 == 0);
+	KASSERT(as->as_pbase2 == 0);
+	KASSERT(as->as_stackpbase == 0);
+
+	as->as_pbase1 = getppages(as->as_npages1);
+	if (as->as_pbase1 == 0) {
+		return ENOMEM;
+	}
+
+	as->as_pbase2 = getppages(as->as_npages2);
+	if (as->as_pbase2 == 0) {
+		return ENOMEM;
+	}
+
+	as->as_stackpbase = getppages(DUMBVM_STACKPAGES);
+	if (as->as_stackpbase == 0) {
+		return ENOMEM;
+	}
+	
+	as_zero_region(as->as_pbase2, as->as_npages2);
+	as_zero_region(as->as_stackpbase, DUMBVM_STACKPAGES);
+
+	return 0;
+}
+
+int
+as_complete_load(struct addrspace *as)
+{
+	(void)as;
+	return 0;
+}
+
+int
+as_define_stack(struct addrspace *as, vaddr_t *stackptr)
+{
+	KASSERT(as->as_stackpbase != 0);
+
+	*stackptr = USERSTACK;
+	return 0;
+}
+
+int
+as_copy(struct addrspace *old, struct addrspace **ret)
+{
+	struct addrspace *new;
+
+	new = as_create();
+	if (new==NULL) {
+		return ENOMEM;
+	}
+
+	new->as_vbase1 = old->as_vbase1;
+	new->as_npages1 = old->as_npages1;
+	new->as_vbase2 = old->as_vbase2;
+	new->as_npages2 = old->as_npages2;
+*/
+	/* (Mis)use as_prepare_load to allocate some physical memory. */
+/*	if (as_prepare_load(new)) {
+		as_destroy(new);
+		return ENOMEM;
+	}
+
+	KASSERT(new->as_pbase1 != 0);
+	KASSERT(new->as_pbase2 != 0);
+	KASSERT(new->as_stackpbase != 0);
+
+	memmove((void *)PADDR_TO_KVADDR(new->as_pbase1),
+		(const void *)PADDR_TO_KVADDR(old->as_pbase1),
+		old->as_npages1*PAGE_SIZE);
+
+	memmove((void *)PADDR_TO_KVADDR(new->as_pbase2),
+		(const void *)PADDR_TO_KVADDR(old->as_pbase2),
+		old->as_npages2*PAGE_SIZE);
+
+	memmove((void *)PADDR_TO_KVADDR(new->as_stackpbase),
+		(const void *)PADDR_TO_KVADDR(old->as_stackpbase),
+		DUMBVM_STACKPAGES*PAGE_SIZE);
+	
+	*ret = new;
+	return 0;
+}*/
diff --git a/src b/src
new file mode 160000
index 0000000..69eae7b
--- /dev/null
+++ b/src
@@ -0,0 +1 @@
+Subproject commit 69eae7bb988b327e88464b7eb44772821b3c3388-dirty
diff --git a/user/lib/libc/unix/err.c b/user/lib/libc/unix/err.c
index a4992d1..82a4941 100644
--- a/user/lib/libc/unix/err.c
+++ b/user/lib/libc/unix/err.c
@@ -95,7 +95,7 @@ __printerr(int use_errno, const char *fmt, va_list ap)
 		prog = __argv[0];
 	}
 	else {
-		prog = "(program name unknown)";
+		prog = "(program name  unknown)";
 	}
 
 	/* print the program name */
diff --git a/user/testbin/fileonlytest/fileonlytest.c b/user/testbin/fileonlytest/fileonlytest.c
index b807ff6..c1bff82 100644
--- a/user/testbin/fileonlytest/fileonlytest.c
+++ b/user/testbin/fileonlytest/fileonlytest.c
@@ -65,7 +65,6 @@ main(int argc, char **argv)
 	const char * filename = "fileonlytest.dat";
 
 	// 23 Mar 2012 : GWA : Test that open works.
-
 	printf("Opening %s\n", filename);
 
 	fh = open(filename, O_RDWR|O_CREAT|O_TRUNC);
@@ -77,6 +76,7 @@ main(int argc, char **argv)
 
   // 23 Mar 2012 : GWA : Do the even-numbered writes. Test read() and
   // lseek(SEEK_END).
+
   
   for (i = 0; i < BUFFER_COUNT / 2; i++) {
 		for (j = 0; j < BUFFER_SIZE; j++) {
@@ -89,6 +89,7 @@ main(int argc, char **argv)
 
     // 23 Mar 2012 : GWA : Use lseek() to skip the odd guys.
 	
+
     target = (i + 1) * 2 * sizeof(writebuf);
     pos = lseek(fh, sizeof(writebuf), SEEK_END);
     if (pos != target) {
@@ -105,10 +106,11 @@ main(int argc, char **argv)
   // 23 Mar 2012 : GWA : Do the odd-numbered writes. Test write() and
   // lseek(SEEK_CUR).
   
+
   for (i = 0; i < BUFFER_COUNT / 2; i++) {
     
     // 23 Mar 2012 : GWA : Use lseek() to skip the even guys.
-    
+ 
     target = ((i * 2) + 1) * sizeof(writebuf);
     pos = lseek(fh, sizeof(writebuf), SEEK_CUR);
     if (pos != target) {
